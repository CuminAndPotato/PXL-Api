// AUTO-GENERATED by skia-to-ts.fsx ��� DO NOT EDIT
// Source assemblies:
//   - SkiaSharp, Version=3.119.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756

/* Utility types for ref/out/in and events */
export type Ref<T> = { value: T };
export type Out<T> = { value?: T };
export type In<T> = { readonly value: T };
export interface DotNetEvent<THandler extends Function> { add(handler: THandler): void; remove(handler: THandler): void; }

export namespace SkiaSharp {
  export enum GRBackend {
    Metal = 0,
    OpenGL = 1,
    Vulkan = 2,
    Dawn = 3,
    Direct3D = 4,
    Unsupported = 5,
  }

  export interface GRBackendRenderTarget {
    readonly IsValid: boolean;
    readonly Width: number;
    readonly Height: number;
    readonly SampleCount: number;
    readonly StencilBits: number;
    readonly Backend: GRBackend;
    readonly Size: SKSizeI;
    readonly Rect: SKRectI;
    Handle: number;
    GetGlFramebufferInfo(): GRGlFramebufferInfo;
    GetGlFramebufferInfo(glInfo: Out<GRGlFramebufferInfo>): boolean;
  }
  export interface GRBackendRenderTarget__statics {
    new(width: number, height: number, sampleCount: number, stencilBits: number, glInfo: GRGlFramebufferInfo): GRBackendRenderTarget;
    new(width: number, height: number, sampleCount: number, vkImageInfo: GRVkImageInfo): GRBackendRenderTarget;
    new(width: number, height: number, vkImageInfo: GRVkImageInfo): GRBackendRenderTarget;
    new(width: number, height: number, d3dTextureInfo: GRD3DTextureResourceInfo): GRBackendRenderTarget;
    new(width: number, height: number, mtlInfo: GRMtlTextureInfo): GRBackendRenderTarget;
  }

  export enum GRBackendState {
    None = 0,
    All = 4294967295,
  }

  export interface GRBackendTexture {
    readonly IsValid: boolean;
    readonly Width: number;
    readonly Height: number;
    readonly HasMipMaps: boolean;
    readonly Backend: GRBackend;
    readonly Size: SKSizeI;
    readonly Rect: SKRectI;
    Handle: number;
    GetGlTextureInfo(): GRGlTextureInfo;
    GetGlTextureInfo(glInfo: Out<GRGlTextureInfo>): boolean;
  }
  export interface GRBackendTexture__statics {
    new(width: number, height: number, mipmapped: boolean, glInfo: GRGlTextureInfo): GRBackendTexture;
    new(width: number, height: number, vkInfo: GRVkImageInfo): GRBackendTexture;
    new(width: number, height: number, d3dTextureInfo: GRD3DTextureResourceInfo): GRBackendTexture;
    new(width: number, height: number, mipmapped: boolean, mtlInfo: GRMtlTextureInfo): GRBackendTexture;
  }

  export interface GRContext {
    readonly Backend: GRBackend;
    readonly IsAbandoned: boolean;
    readonly MaxTextureSize: number;
    readonly MaxRenderTargetSize: number;
    Handle: number;
    AbandonContext(releaseResources?: boolean): void;
    DumpMemoryStatistics(dump: SKTraceMemoryDump): void;
    Flush(): void;
    Flush(submit: boolean, synchronous?: boolean): void;
    GetMaxSurfaceSampleCount(colorType: SKColorType): number;
    GetMaxSurfaceSampleCount(colorType: SKColorType): number;
    GetResourceCacheLimit(): number;
    GetResourceCacheUsage(maxResources: Out<number>, maxResourceBytes: Out<number>): void;
    PurgeResources(): void;
    PurgeUnlockedResources(scratchResourcesOnly: boolean): void;
    PurgeUnlockedResources(bytesToPurge: number, preferScratchResources: boolean): void;
    PurgeUnusedResources(milliseconds: number): void;
    ResetContext(state: GRGlBackendState): void;
    ResetContext(state?: GRBackendState): void;
    ResetContext(state: number): void;
    SetResourceCacheLimit(maxResourceBytes: number): void;
    Submit(synchronous?: boolean): void;
  }
  export interface GRContext__statics {
    CreateGl(): GRContext;
    CreateGl(backendContext: GRGlInterface): GRContext;
    CreateGl(options: GRContextOptions): GRContext;
    CreateGl(backendContext: GRGlInterface, options: GRContextOptions): GRContext;
    CreateVulkan(backendContext: GRVkBackendContext): GRContext;
    CreateVulkan(backendContext: GRVkBackendContext, options: GRContextOptions): GRContext;
    CreateDirect3D(backendContext: GRD3DBackendContext): GRContext;
    CreateDirect3D(backendContext: GRD3DBackendContext, options: GRContextOptions): GRContext;
    CreateMetal(backendContext: GRMtlBackendContext): GRContext;
    CreateMetal(backendContext: GRMtlBackendContext, options: GRContextOptions): GRContext;
  }

  export interface GRContextOptions {
    AvoidStencilBuffers: boolean;
    RuntimeProgramCacheSize: number;
    GlyphCacheTextureMaximumBytes: number;
    AllowPathMaskCaching: boolean;
    DoManualMipmapping: boolean;
    BufferMapThreshold: number;
  }
  export interface GRContextOptions__statics {
    new(): GRContextOptions;
  }

  export interface GRD3DBackendContext {
    Adapter: number;
    Device: number;
    Queue: number;
    ProtectedContext: boolean;
  }
  export interface GRD3DBackendContext__statics {
    new(): GRD3DBackendContext;
  }

  export interface GRD3DTextureResourceInfo {
    Resource: number;
    ResourceState: number;
    Format: number;
    SampleCount: number;
    LevelCount: number;
    SampleQualityPattern: number;
    Protected: boolean;
  }
  export interface GRD3DTextureResourceInfo__statics {
    new(): GRD3DTextureResourceInfo;
  }

  export enum GRGlBackendState {
    None = 0,
    RenderTarget = 1,
    TextureBinding = 2,
    View = 4,
    Blend = 8,
    MSAAEnable = 16,
    Vertex = 32,
    Stencil = 64,
    PixelStore = 128,
    Program = 256,
    FixedFunction = 512,
    Misc = 1024,
    PathRendering = 2048,
    All = 65535,
  }

  export interface GRGlFramebufferInfo {
    FramebufferObjectId: number;
    Format: number;
    Protected: boolean;
    Equals(obj: GRGlFramebufferInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface GRGlFramebufferInfo__statics {
    new(fboId: number): GRGlFramebufferInfo;
    new(fboId: number, format: number): GRGlFramebufferInfo;
  }

  export type GRGlGetProcedureAddressDelegate = (name: string) => number;

  export interface GRGlInterface {
    Handle: number;
    HasExtension(extension: string): boolean;
    Validate(): boolean;
  }
  export interface GRGlInterface__statics {
    Create(): GRGlInterface;
    CreateAngle(): GRGlInterface;
    Create(get: GRGlGetProcedureAddressDelegate): GRGlInterface;
    CreateAngle(get: GRGlGetProcedureAddressDelegate): GRGlInterface;
    CreateOpenGl(get: GRGlGetProcedureAddressDelegate): GRGlInterface;
    CreateGles(get: GRGlGetProcedureAddressDelegate): GRGlInterface;
    CreateWebGl(get: GRGlGetProcedureAddressDelegate): GRGlInterface;
    CreateEvas(evas: number): GRGlInterface;
  }

  export interface GRGlTextureInfo {
    Target: number;
    Id: number;
    Format: number;
    Protected: boolean;
    Equals(obj: GRGlTextureInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface GRGlTextureInfo__statics {
    new(target: number, id: number): GRGlTextureInfo;
    new(target: number, id: number, format: number): GRGlTextureInfo;
  }

  export interface GRMtlBackendContext {
    DeviceHandle: number;
    QueueHandle: number;
  }
  export interface GRMtlBackendContext__statics {
    new(): GRMtlBackendContext;
  }

  export interface GRMtlTextureInfo {
    TextureHandle: number;
    Equals(obj: GRMtlTextureInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface GRMtlTextureInfo__statics {
    new(textureHandle: number): GRMtlTextureInfo;
  }

  export interface GRRecordingContext {
    readonly Backend: GRBackend;
    readonly IsAbandoned: boolean;
    readonly MaxTextureSize: number;
    readonly MaxRenderTargetSize: number;
    Handle: number;
    GetMaxSurfaceSampleCount(colorType: SKColorType): number;
  }
  export enum GRSurfaceOrigin {
    TopLeft = 0,
    BottomLeft = 1,
  }

  export interface GRVkAlloc {
    Memory: number;
    Offset: number;
    Size: number;
    Flags: number;
    BackendMemory: number;
    Equals(obj: GRVkAlloc): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface GRVkBackendContext {
    VkInstance: number;
    VkPhysicalDevice: number;
    VkDevice: number;
    VkQueue: number;
    GraphicsQueueIndex: number;
    MaxAPIVersion: number;
    Extensions: GRVkExtensions;
    VkPhysicalDeviceFeatures: number;
    VkPhysicalDeviceFeatures2: number;
    GetProcedureAddress: GRVkGetProcedureAddressDelegate;
    ProtectedContext: boolean;
  }
  export interface GRVkBackendContext__statics {
    new(): GRVkBackendContext;
  }

  export interface GRVkExtensions {
    Handle: number;
    HasExtension(extension: string, minVersion: number): void;
    Initialize(getProc: GRVkGetProcedureAddressDelegate, vkInstance: number, vkPhysicalDevice: number): void;
    Initialize(getProc: GRVkGetProcedureAddressDelegate, vkInstance: number, vkPhysicalDevice: number, instanceExtensions: string[], deviceExtensions: string[]): void;
  }
  export interface GRVkExtensions__statics {
    Create(getProc: GRVkGetProcedureAddressDelegate, vkInstance: number, vkPhysicalDevice: number, instanceExtensions: string[], deviceExtensions: string[]): GRVkExtensions;
  }

  export type GRVkGetProcedureAddressDelegate = (name: string, instance: number, device: number) => number;

  export interface GRVkImageInfo {
    Image: number;
    Alloc: GRVkAlloc;
    ImageTiling: number;
    ImageLayout: number;
    Format: number;
    ImageUsageFlags: number;
    SampleCount: number;
    LevelCount: number;
    CurrentQueueFamily: number;
    Protected: boolean;
    YcbcrConversionInfo: GrVkYcbcrConversionInfo;
    SharingMode: number;
    Equals(obj: GRVkImageInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface GrVkYcbcrConversionInfo {
    Format: number;
    ExternalFormat: number;
    YcbcrModel: number;
    YcbcrRange: number;
    XChromaOffset: number;
    YChromaOffset: number;
    ChromaFilter: number;
    ForceExplicitReconstruction: number;
    FormatFeatures: number;
    Equals(obj: GrVkYcbcrConversionInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKAbstractManagedStream {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKAbstractManagedWStream {
    readonly BytesWritten: number;
    Handle: number;
    Flush(): void;
    NewLine(): boolean;
    Write(buffer: number[], size: number): boolean;
    Write16(value: number): boolean;
    Write32(value: number): boolean;
    Write8(value: number): boolean;
    WriteBigDecimalAsText(value: number, digits: number): boolean;
    WriteBool(value: boolean): boolean;
    WriteDecimalAsTest(value: number): boolean;
    WriteHexAsText(value: number, digits: number): boolean;
    WritePackedUInt32(value: number): boolean;
    WriteScalar(value: number): boolean;
    WriteScalarAsText(value: number): boolean;
    WriteStream(input: SKStream, length: number): boolean;
    WriteText(value: string): boolean;
  }
  export enum SKAlphaType {
    Unknown = 0,
    Opaque = 1,
    Premul = 2,
    Unpremul = 3,
  }

  export interface SKAutoCanvasRestore {
    Restore(): void;
  }
  export interface SKAutoCanvasRestore__statics {
    new(canvas: SKCanvas): SKAutoCanvasRestore;
    new(canvas: SKCanvas, doSave: boolean): SKAutoCanvasRestore;
  }

  export interface SKAutoCoInitialize {
    readonly Initialized: boolean;
    Uninitialize(): void;
  }
  export interface SKAutoCoInitialize__statics {
    new(): SKAutoCoInitialize;
  }

  export interface SKBitmap {
    readonly ReadyToDraw: boolean;
    readonly Info: SKImageInfo;
    readonly Width: number;
    readonly Height: number;
    readonly ColorType: SKColorType;
    readonly AlphaType: SKAlphaType;
    readonly ColorSpace: SKColorSpace;
    readonly BytesPerPixel: number;
    readonly RowBytes: number;
    readonly ByteCount: number;
    readonly Bytes: number[];
    Pixels: SKColor[];
    readonly IsEmpty: boolean;
    readonly IsNull: boolean;
    readonly DrawsNothing: boolean;
    readonly IsImmutable: boolean;
    Handle: number;
    CanCopyTo(colorType: SKColorType): boolean;
    Copy(): SKBitmap;
    Copy(colorType: SKColorType): SKBitmap;
    CopyTo(destination: SKBitmap): boolean;
    CopyTo(destination: SKBitmap, colorType: SKColorType): boolean;
    Encode(format: SKEncodedImageFormat, quality: number): SKData;
    Encode(dst: SKWStream, format: SKEncodedImageFormat, quality: number): boolean;
    Erase(color: SKColor): void;
    Erase(color: SKColor, rect: SKRectI): void;
    ExtractAlpha(destination: SKBitmap): boolean;
    ExtractAlpha(destination: SKBitmap, paint: SKPaint): boolean;
    ExtractAlpha(destination: SKBitmap, offset: Out<SKPointI>): boolean;
    ExtractAlpha(destination: SKBitmap, paint: SKPaint, offset: Out<SKPointI>): boolean;
    ExtractSubset(destination: SKBitmap, subset: SKRectI): boolean;
    GetAddress(x: number, y: number): number;
    GetPixel(x: number, y: number): SKColor;
    GetPixels(): number;
    GetPixels(length: Out<number>): number;
    InstallPixels(pixmap: SKPixmap): boolean;
    InstallPixels(info: SKImageInfo, pixels: number): boolean;
    InstallPixels(info: SKImageInfo, pixels: number, rowBytes: number): boolean;
    InstallPixels(info: SKImageInfo, pixels: number, rowBytes: number, releaseProc: SKBitmapReleaseDelegate): boolean;
    InstallPixels(info: SKImageInfo, pixels: number, rowBytes: number, releaseProc: SKBitmapReleaseDelegate, context: any): boolean;
    NotifyPixelsChanged(): void;
    PeekPixels(): SKPixmap;
    PeekPixels(pixmap: SKPixmap): boolean;
    Reset(): void;
    Resize(info: SKImageInfo, quality: SKFilterQuality): SKBitmap;
    Resize(size: SKSizeI, quality: SKFilterQuality): SKBitmap;
    Resize(info: SKImageInfo, sampling: SKSamplingOptions): SKBitmap;
    Resize(size: SKSizeI, sampling: SKSamplingOptions): SKBitmap;
    ScalePixels(destination: SKPixmap, sampling: SKSamplingOptions): boolean;
    ScalePixels(destination: SKBitmap, sampling: SKSamplingOptions): boolean;
    ScalePixels(destination: SKPixmap, quality: SKFilterQuality): boolean;
    ScalePixels(destination: SKBitmap, quality: SKFilterQuality): boolean;
    SetImmutable(): void;
    SetPixel(x: number, y: number, color: SKColor): void;
    SetPixels(pixels: number): void;
    ToShader(): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, sampling: SKSamplingOptions): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, quality: SKFilterQuality): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, quality: SKFilterQuality, localMatrix: SKMatrix): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, sampling: SKSamplingOptions, localMatrix: SKMatrix): SKShader;
    TryAllocPixels(info: SKImageInfo): boolean;
    TryAllocPixels(info: SKImageInfo, flags: SKBitmapAllocFlags): boolean;
    TryAllocPixels(info: SKImageInfo, rowBytes: number): boolean;
  }
  export interface SKBitmap__statics {
    new(): SKBitmap;
    new(width: number, height: number, isOpaque?: boolean): SKBitmap;
    new(width: number, height: number, colorType: SKColorType, alphaType: SKAlphaType): SKBitmap;
    new(width: number, height: number, colorType: SKColorType, alphaType: SKAlphaType, colorspace: SKColorSpace): SKBitmap;
    new(info: SKImageInfo): SKBitmap;
    new(info: SKImageInfo, rowBytes: number): SKBitmap;
    new(info: SKImageInfo, flags: SKBitmapAllocFlags): SKBitmap;
    DecodeBounds(stream: SKStream): SKImageInfo;
    DecodeBounds(data: SKData): SKImageInfo;
    DecodeBounds(filename: string): SKImageInfo;
    DecodeBounds(buffer: number[]): SKImageInfo;
    Decode(codec: SKCodec): SKBitmap;
    Decode(codec: SKCodec, bitmapInfo: SKImageInfo): SKBitmap;
    Decode(stream: SKStream): SKBitmap;
    Decode(stream: SKStream, bitmapInfo: SKImageInfo): SKBitmap;
    Decode(data: SKData): SKBitmap;
    Decode(data: SKData, bitmapInfo: SKImageInfo): SKBitmap;
    Decode(filename: string): SKBitmap;
    Decode(filename: string, bitmapInfo: SKImageInfo): SKBitmap;
    Decode(buffer: number[]): SKBitmap;
    Decode(buffer: number[], bitmapInfo: SKImageInfo): SKBitmap;
    FromImage(image: SKImage): SKBitmap;
  }

  export enum SKBitmapAllocFlags {
    None = 0,
    ZeroPixels = 1,
  }

  export type SKBitmapReleaseDelegate = (address: number, context: any) => void;

  export enum SKBlendMode {
    Clear = 0,
    Src = 1,
    Dst = 2,
    SrcOver = 3,
    DstOver = 4,
    SrcIn = 5,
    DstIn = 6,
    SrcOut = 7,
    DstOut = 8,
    SrcATop = 9,
    DstATop = 10,
    Xor = 11,
    Plus = 12,
    Modulate = 13,
    Screen = 14,
    Overlay = 15,
    Darken = 16,
    Lighten = 17,
    ColorDodge = 18,
    ColorBurn = 19,
    HardLight = 20,
    SoftLight = 21,
    Difference = 22,
    Exclusion = 23,
    Multiply = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28,
  }

  export interface SKBlender {
    Handle: number;
  }
  export interface SKBlender__statics {
    CreateBlendMode(mode: SKBlendMode): SKBlender;
    CreateArithmetic(k1: number, k2: number, k3: number, k4: number, enforcePMColor: boolean): SKBlender;
  }

  export enum SKBlurStyle {
    Normal = 0,
    Solid = 1,
    Outer = 2,
    Inner = 3,
  }

  export interface SKCanvas {
    readonly LocalClipBounds: SKRect;
    readonly DeviceClipBounds: SKRectI;
    readonly IsClipEmpty: boolean;
    readonly IsClipRect: boolean;
    readonly Surface: SKSurface;
    readonly Context: GRRecordingContext;
    readonly TotalMatrix: SKMatrix;
    readonly TotalMatrix44: SKMatrix44;
    readonly SaveCount: number;
    Handle: number;
    Clear(): void;
    Clear(color: SKColorF): void;
    Clear(color: SKColor): void;
    ClipPath(path: SKPath, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRect(rect: SKRect, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRegion(region: SKRegion, operation?: SKClipOperation): void;
    ClipRoundRect(rect: SKRoundRect, operation?: SKClipOperation, antialias?: boolean): void;
    Concat(m: Ref<SKMatrix>): void;
    Concat(m: Ref<SKMatrix44>): void;
    Discard(): void;
    DrawAnnotation(rect: SKRect, key: string, value: SKData): void;
    DrawArc(oval: SKRect, startAngle: number, sweepAngle: number, useCenter: boolean, paint: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, cullRect: SKRect, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, cullRect: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, p: SKPoint, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, x: number, y: number, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawCircle(c: SKPoint, radius: number, paint: SKPaint): void;
    DrawCircle(cx: number, cy: number, radius: number, paint: SKPaint): void;
    DrawColor(color: SKColor, mode?: SKBlendMode): void;
    DrawColor(color: SKColorF, mode?: SKBlendMode): void;
    DrawDrawable(drawable: SKDrawable, p: SKPoint): void;
    DrawDrawable(drawable: SKDrawable, matrix: Ref<SKMatrix>): void;
    DrawDrawable(drawable: SKDrawable, x: number, y: number): void;
    DrawImage(image: SKImage, p: SKPoint, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, filterMode?: SKFilterMode, paint?: SKPaint): void;
    DrawLine(p0: SKPoint, p1: SKPoint, paint: SKPaint): void;
    DrawLine(x0: number, y0: number, x1: number, y1: number, paint: SKPaint): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: SKData): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: string): SKData;
    DrawNamedDestinationAnnotation(point: SKPoint, value: SKData): void;
    DrawNamedDestinationAnnotation(point: SKPoint, value: string): SKData;
    DrawOval(rect: SKRect, paint: SKPaint): void;
    DrawOval(c: SKPoint, r: SKSize, paint: SKPaint): void;
    DrawOval(cx: number, cy: number, rx: number, ry: number, paint: SKPaint): void;
    DrawPaint(paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], mode: SKBlendMode, paint: SKPaint): void;
    DrawPath(path: SKPath, paint: SKPaint): void;
    DrawPicture(picture: SKPicture, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, p: SKPoint, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, matrix: Ref<SKMatrix>, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, x: number, y: number, paint?: SKPaint): void;
    DrawPoint(p: SKPoint, color: SKColor): void;
    DrawPoint(p: SKPoint, paint: SKPaint): void;
    DrawPoint(x: number, y: number, color: SKColor): void;
    DrawPoint(x: number, y: number, paint: SKPaint): void;
    DrawPoints(mode: SKPointMode, points: SKPoint[], paint: SKPaint): void;
    DrawRect(rect: SKRect, paint: SKPaint): void;
    DrawRect(x: number, y: number, w: number, h: number, paint: SKPaint): void;
    DrawRegion(region: SKRegion, paint: SKPaint): void;
    DrawRoundRect(rect: SKRoundRect, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, r: SKSize, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRect(x: number, y: number, w: number, h: number, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRectDifference(outer: SKRoundRect, inner: SKRoundRect, paint: SKPaint): void;
    DrawSurface(surface: SKSurface, p: SKPoint, paint?: SKPaint): void;
    DrawSurface(surface: SKSurface, x: number, y: number, paint?: SKPaint): void;
    DrawText(text: string, p: SKPoint, paint: SKPaint): void;
    DrawText(text: SKTextBlob, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawUrlAnnotation(rect: SKRect, value: string): SKData;
    DrawUrlAnnotation(rect: SKRect, value: SKData): void;
    DrawVertices(vertices: SKVertices, mode: SKBlendMode, paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], indices: number[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], mode: SKBlendMode, indices: number[], paint: SKPaint): void;
    Flush(): void;
    GetDeviceClipBounds(bounds: Out<SKRectI>): boolean;
    GetLocalClipBounds(bounds: Out<SKRect>): boolean;
    QuickReject(rect: SKRect): boolean;
    QuickReject(path: SKPath): boolean;
    ResetMatrix(): void;
    Restore(): void;
    RestoreToCount(count: number): void;
    RotateDegrees(degrees: number): void;
    RotateDegrees(degrees: number, px: number, py: number): void;
    RotateRadians(radians: number): void;
    RotateRadians(radians: number, px: number, py: number): void;
    Save(): number;
    SaveLayer(): number;
    SaveLayer(paint: SKPaint): number;
    SaveLayer(rec: Ref<SKCanvasSaveLayerRec>): number;
    SaveLayer(limit: SKRect, paint: SKPaint): number;
    Scale(s: number): void;
    Scale(size: SKPoint): void;
    Scale(sx: number, sy: number): void;
    Scale(sx: number, sy: number, px: number, py: number): void;
    SetMatrix(matrix: Ref<SKMatrix>): void;
    SetMatrix(matrix: SKMatrix): void;
    SetMatrix(matrix: Ref<SKMatrix44>): void;
    Skew(skew: SKPoint): void;
    Skew(sx: number, sy: number): void;
    Translate(point: SKPoint): void;
    Translate(dx: number, dy: number): void;
  }
  export interface SKCanvas__statics {
    new(bitmap: SKBitmap): SKCanvas;
  }

  export interface SKCanvasSaveLayerRec {
    Bounds: SKRect | null;
    Paint: SKPaint;
    Backdrop: SKImageFilter;
    Flags: SKCanvasSaveLayerRecFlags;
  }
  export enum SKCanvasSaveLayerRecFlags {
    None = 0,
    PreserveLcdText = 2,
    InitializeWithPrevious = 4,
    F16ColorType = 16,
  }

  export enum SKClipOperation {
    Difference = 0,
    Intersect = 1,
  }

  export interface SKCodec {
    readonly Info: SKImageInfo;
    readonly EncodedOrigin: SKEncodedOrigin;
    readonly EncodedFormat: SKEncodedImageFormat;
    readonly Pixels: number[];
    readonly RepetitionCount: number;
    readonly FrameCount: number;
    readonly FrameInfo: SKCodecFrameInfo[];
    readonly ScanlineOrder: SKCodecScanlineOrder;
    readonly NextScanline: number;
    Handle: number;
    GetFrameInfo(index: number, frameInfo: Out<SKCodecFrameInfo>): boolean;
    GetOutputScanline(inputScanline: number): number;
    GetPixels(pixels: Out<number[]>): SKCodecResult;
    GetPixels(info: SKImageInfo, pixels: Out<number[]>): SKCodecResult;
    GetPixels(info: SKImageInfo, pixels: number[]): SKCodecResult;
    GetPixels(info: SKImageInfo, pixels: number): SKCodecResult;
    GetPixels(info: SKImageInfo, pixels: number, options: SKCodecOptions): SKCodecResult;
    GetPixels(info: SKImageInfo, pixels: number, rowBytes: number, options: SKCodecOptions): SKCodecResult;
    GetScaledDimensions(desiredScale: number): SKSizeI;
    GetScanlines(dst: number, countLines: number, rowBytes: number): number;
    GetValidSubset(desiredSubset: Ref<SKRectI>): boolean;
    IncrementalDecode(): SKCodecResult;
    IncrementalDecode(rowsDecoded: Out<number>): SKCodecResult;
    SkipScanlines(countLines: number): boolean;
    StartIncrementalDecode(info: SKImageInfo, pixels: number, rowBytes: number): SKCodecResult;
    StartIncrementalDecode(info: SKImageInfo, pixels: number, rowBytes: number, options: SKCodecOptions): SKCodecResult;
    StartScanlineDecode(info: SKImageInfo): SKCodecResult;
    StartScanlineDecode(info: SKImageInfo, options: SKCodecOptions): SKCodecResult;
  }
  export interface SKCodec__statics {
    MinBufferedBytesNeeded: number;
    Create(filename: string): SKCodec;
    Create(filename: string, result: Out<SKCodecResult>): SKCodec;
    Create(stream: SKStream): SKCodec;
    Create(stream: SKStream, result: Out<SKCodecResult>): SKCodec;
    Create(data: SKData): SKCodec;
  }

  export enum SKCodecAnimationBlend {
    SrcOver = 0,
    Src = 1,
  }

  export enum SKCodecAnimationDisposalMethod {
    Keep = 1,
    RestoreBackgroundColor = 2,
    RestorePrevious = 3,
  }

  export interface SKCodecFrameInfo {
    RequiredFrame: number;
    Duration: number;
    FullyRecieved: boolean;
    AlphaType: SKAlphaType;
    HasAlphaWithinBounds: boolean;
    DisposalMethod: SKCodecAnimationDisposalMethod;
    Blend: SKCodecAnimationBlend;
    FrameRect: SKRectI;
    Equals(obj: SKCodecFrameInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKCodecOptions {
    ZeroInitialized: SKZeroInitialized;
    Subset: SKRectI | null;
    readonly HasSubset: boolean;
    FrameIndex: number;
    PriorFrame: number;
    Equals(obj: SKCodecOptions): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKCodecOptions__statics {
    new(zeroInitialized: SKZeroInitialized): SKCodecOptions;
    new(zeroInitialized: SKZeroInitialized, subset: SKRectI): SKCodecOptions;
    new(subset: SKRectI): SKCodecOptions;
    new(frameIndex: number): SKCodecOptions;
    new(frameIndex: number, priorFrame: number): SKCodecOptions;
    Default: SKCodecOptions;
  }

  export enum SKCodecResult {
    Success = 0,
    IncompleteInput = 1,
    ErrorInInput = 2,
    InvalidConversion = 3,
    InvalidScale = 4,
    InvalidParameters = 5,
    InvalidInput = 6,
    CouldNotRewind = 7,
    InternalError = 8,
    Unimplemented = 9,
  }

  export enum SKCodecScanlineOrder {
    TopDown = 0,
    BottomUp = 1,
  }

  export interface SKColor {
    readonly Alpha: number;
    readonly Red: number;
    readonly Green: number;
    readonly Blue: number;
    readonly Hue: number;
    Equals(obj: SKColor): boolean;
    Equals(other: any): boolean;
    GetHashCode(): number;
    ToHsl(h: Out<number>, s: Out<number>, l: Out<number>): void;
    ToHsv(h: Out<number>, s: Out<number>, v: Out<number>): void;
    ToString(): string;
    WithAlpha(alpha: number): SKColor;
    WithBlue(blue: number): SKColor;
    WithGreen(green: number): SKColor;
    WithRed(red: number): SKColor;
  }
  export interface SKColor__statics {
    new(value: number): SKColor;
    new(red: number, green: number, blue: number, alpha: number): SKColor;
    new(red: number, green: number, blue: number): SKColor;
    Empty: SKColor;
    FromHsl(h: number, s: number, l: number, a?: number): SKColor;
    FromHsv(h: number, s: number, v: number, a?: number): SKColor;
    Parse(hexString: string): SKColor;
    TryParse(hexString: string, color: Out<SKColor>): boolean;
  }

  export enum SKColorChannel {
    R = 0,
    G = 1,
    B = 2,
    A = 3,
  }

  export interface SKColorF {
    readonly Hue: number;
    readonly Red: number;
    readonly Green: number;
    readonly Blue: number;
    readonly Alpha: number;
    Clamp(): SKColorF;
    Equals(obj: SKColorF): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToHsl(h: Out<number>, s: Out<number>, l: Out<number>): void;
    ToHsv(h: Out<number>, s: Out<number>, v: Out<number>): void;
    ToString(): string;
    WithAlpha(alpha: number): SKColorF;
    WithBlue(blue: number): SKColorF;
    WithGreen(green: number): SKColorF;
    WithRed(red: number): SKColorF;
  }
  export interface SKColorF__statics {
    new(red: number, green: number, blue: number): SKColorF;
    new(red: number, green: number, blue: number, alpha: number): SKColorF;
    Empty: SKColorF;
    FromHsl(h: number, s: number, l: number, a?: number): SKColorF;
    FromHsv(h: number, s: number, v: number, a?: number): SKColorF;
  }

  export interface SKColorFilter {
    Handle: number;
  }
  export interface SKColorFilter__statics {
    ColorMatrixSize: number;
    TableMaxLength: number;
    CreateSrgbToLinearGamma(): SKColorFilter;
    CreateLinearToSrgbGamma(): SKColorFilter;
    CreateBlendMode(c: SKColor, mode: SKBlendMode): SKColorFilter;
    CreateLighting(mul: SKColor, add: SKColor): SKColorFilter;
    CreateCompose(outer: SKColorFilter, inner: SKColorFilter): SKColorFilter;
    CreateLerp(weight: number, filter0: SKColorFilter, filter1: SKColorFilter): SKColorFilter;
    CreateColorMatrix(matrix: number[]): SKColorFilter;
    CreateLumaColor(): SKColorFilter;
    CreateTable(table: number[]): SKColorFilter;
    CreateTable(tableA: number[], tableR: number[], tableG: number[], tableB: number[]): SKColorFilter;
    CreateHighContrast(config: SKHighContrastConfig): SKColorFilter;
    CreateHighContrast(grayscale: boolean, invertStyle: SKHighContrastConfigInvertStyle, contrast: number): SKColorFilter;
  }

  export interface SKColorSpace {
    readonly GammaIsCloseToSrgb: boolean;
    readonly GammaIsLinear: boolean;
    readonly IsSrgb: boolean;
    readonly IsNumericalTransferFunction: boolean;
    Handle: number;
    GetNumericalTransferFunction(): SKColorSpaceTransferFn;
    GetNumericalTransferFunction(fn: Out<SKColorSpaceTransferFn>): boolean;
    ToColorSpaceXyz(): SKColorSpaceXyz;
    ToColorSpaceXyz(toXyzD50: Out<SKColorSpaceXyz>): boolean;
    ToLinearGamma(): SKColorSpace;
    ToProfile(): SKColorSpaceIccProfile;
    ToSrgbGamma(): SKColorSpace;
  }
  export interface SKColorSpace__statics {
    Equal(left: SKColorSpace, right: SKColorSpace): boolean;
    CreateSrgb(): SKColorSpace;
    CreateSrgbLinear(): SKColorSpace;
    CreateIcc(input: number, length: number): SKColorSpace;
    CreateIcc(input: number[], length: number): SKColorSpace;
    CreateIcc(input: number[]): SKColorSpace;
    CreateIcc(input: SKData): SKColorSpace;
    CreateIcc(profile: SKColorSpaceIccProfile): SKColorSpace;
    CreateRgb(transferFn: SKColorSpaceTransferFn, toXyzD50: SKColorSpaceXyz): SKColorSpace;
  }

  export interface SKColorSpaceIccProfile {
    readonly Size: number;
    readonly Buffer: number;
    Handle: number;
    ToColorSpaceXyz(): SKColorSpaceXyz;
    ToColorSpaceXyz(toXyzD50: Out<SKColorSpaceXyz>): boolean;
  }
  export interface SKColorSpaceIccProfile__statics {
    new(): SKColorSpaceIccProfile;
    Create(data: number[]): SKColorSpaceIccProfile;
    Create(data: SKData): SKColorSpaceIccProfile;
    Create(data: number, length: number): SKColorSpaceIccProfile;
  }

  export interface SKColorSpacePrimaries {
    readonly Values: number[];
    RX: number;
    RY: number;
    GX: number;
    GY: number;
    BX: number;
    BY: number;
    WX: number;
    WY: number;
    Equals(obj: SKColorSpacePrimaries): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToColorSpaceXyz(): SKColorSpaceXyz;
    ToColorSpaceXyz(toXyzD50: Out<SKColorSpaceXyz>): boolean;
  }
  export interface SKColorSpacePrimaries__statics {
    new(values: number[]): SKColorSpacePrimaries;
    new(rx: number, ry: number, gx: number, gy: number, bx: number, by: number, wx: number, wy: number): SKColorSpacePrimaries;
    Empty: SKColorSpacePrimaries;
  }

  export interface SKColorSpaceTransferFn {
    readonly Values: number[];
    G: number;
    A: number;
    B: number;
    C: number;
    D: number;
    E: number;
    F: number;
    Equals(obj: SKColorSpaceTransferFn): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Invert(): SKColorSpaceTransferFn;
    Transform(x: number): number;
  }
  export interface SKColorSpaceTransferFn__statics {
    new(values: number[]): SKColorSpaceTransferFn;
    new(g: number, a: number, b: number, c: number, d: number, e: number, f: number): SKColorSpaceTransferFn;
    Empty: SKColorSpaceTransferFn;
    Srgb: SKColorSpaceTransferFn;
    TwoDotTwo: SKColorSpaceTransferFn;
    Linear: SKColorSpaceTransferFn;
    Rec2020: SKColorSpaceTransferFn;
    Pq: SKColorSpaceTransferFn;
    Hlg: SKColorSpaceTransferFn;
  }

  export interface SKColorSpaceXyz {
    Values: number[];
    get_Item(x: number, y: number): number;
    Equals(obj: SKColorSpaceXyz): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Invert(): SKColorSpaceXyz;
  }
  export interface SKColorSpaceXyz__statics {
    new(value: number): SKColorSpaceXyz;
    new(values: number[]): SKColorSpaceXyz;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): SKColorSpaceXyz;
    Empty: SKColorSpaceXyz;
    Identity: SKColorSpaceXyz;
    Srgb: SKColorSpaceXyz;
    AdobeRgb: SKColorSpaceXyz;
    DisplayP3: SKColorSpaceXyz;
    Rec2020: SKColorSpaceXyz;
    Xyz: SKColorSpaceXyz;
    Concat(a: SKColorSpaceXyz, b: SKColorSpaceXyz): SKColorSpaceXyz;
  }

  export enum SKColorType {
    Unknown = 0,
    Alpha8 = 1,
    Rgb565 = 2,
    Argb4444 = 3,
    Rgba8888 = 4,
    Rgb888x = 5,
    Bgra8888 = 6,
    Rgba1010102 = 7,
    Rgb101010x = 8,
    Gray8 = 9,
    RgbaF16 = 10,
    RgbaF16Clamped = 11,
    RgbaF32 = 12,
    Rg88 = 13,
    AlphaF16 = 14,
    RgF16 = 15,
    Alpha16 = 16,
    Rg1616 = 17,
    Rgba16161616 = 18,
    Bgra1010102 = 19,
    Bgr101010x = 20,
    Bgr101010xXR = 21,
    Srgba8888 = 22,
    R8Unorm = 23,
    Rgba10x6 = 24,
  }

  export interface SKColors {
  }
  export interface SKColors__statics {
    AliceBlue: SKColor;
    AntiqueWhite: SKColor;
    Aqua: SKColor;
    Aquamarine: SKColor;
    Azure: SKColor;
    Beige: SKColor;
    Bisque: SKColor;
    Black: SKColor;
    BlanchedAlmond: SKColor;
    Blue: SKColor;
    BlueViolet: SKColor;
    Brown: SKColor;
    BurlyWood: SKColor;
    CadetBlue: SKColor;
    Chartreuse: SKColor;
    Chocolate: SKColor;
    Coral: SKColor;
    CornflowerBlue: SKColor;
    Cornsilk: SKColor;
    Crimson: SKColor;
    Cyan: SKColor;
    DarkBlue: SKColor;
    DarkCyan: SKColor;
    DarkGoldenrod: SKColor;
    DarkGray: SKColor;
    DarkGreen: SKColor;
    DarkKhaki: SKColor;
    DarkMagenta: SKColor;
    DarkOliveGreen: SKColor;
    DarkOrange: SKColor;
    DarkOrchid: SKColor;
    DarkRed: SKColor;
    DarkSalmon: SKColor;
    DarkSeaGreen: SKColor;
    DarkSlateBlue: SKColor;
    DarkSlateGray: SKColor;
    DarkTurquoise: SKColor;
    DarkViolet: SKColor;
    DeepPink: SKColor;
    DeepSkyBlue: SKColor;
    DimGray: SKColor;
    DodgerBlue: SKColor;
    Firebrick: SKColor;
    FloralWhite: SKColor;
    ForestGreen: SKColor;
    Fuchsia: SKColor;
    Gainsboro: SKColor;
    GhostWhite: SKColor;
    Gold: SKColor;
    Goldenrod: SKColor;
    Gray: SKColor;
    Green: SKColor;
    GreenYellow: SKColor;
    Honeydew: SKColor;
    HotPink: SKColor;
    IndianRed: SKColor;
    Indigo: SKColor;
    Ivory: SKColor;
    Khaki: SKColor;
    Lavender: SKColor;
    LavenderBlush: SKColor;
    LawnGreen: SKColor;
    LemonChiffon: SKColor;
    LightBlue: SKColor;
    LightCoral: SKColor;
    LightCyan: SKColor;
    LightGoldenrodYellow: SKColor;
    LightGray: SKColor;
    LightGreen: SKColor;
    LightPink: SKColor;
    LightSalmon: SKColor;
    LightSeaGreen: SKColor;
    LightSkyBlue: SKColor;
    LightSlateGray: SKColor;
    LightSteelBlue: SKColor;
    LightYellow: SKColor;
    Lime: SKColor;
    LimeGreen: SKColor;
    Linen: SKColor;
    Magenta: SKColor;
    Maroon: SKColor;
    MediumAquamarine: SKColor;
    MediumBlue: SKColor;
    MediumOrchid: SKColor;
    MediumPurple: SKColor;
    MediumSeaGreen: SKColor;
    MediumSlateBlue: SKColor;
    MediumSpringGreen: SKColor;
    MediumTurquoise: SKColor;
    MediumVioletRed: SKColor;
    MidnightBlue: SKColor;
    MintCream: SKColor;
    MistyRose: SKColor;
    Moccasin: SKColor;
    NavajoWhite: SKColor;
    Navy: SKColor;
    OldLace: SKColor;
    Olive: SKColor;
    OliveDrab: SKColor;
    Orange: SKColor;
    OrangeRed: SKColor;
    Orchid: SKColor;
    PaleGoldenrod: SKColor;
    PaleGreen: SKColor;
    PaleTurquoise: SKColor;
    PaleVioletRed: SKColor;
    PapayaWhip: SKColor;
    PeachPuff: SKColor;
    Peru: SKColor;
    Pink: SKColor;
    Plum: SKColor;
    PowderBlue: SKColor;
    Purple: SKColor;
    Red: SKColor;
    RosyBrown: SKColor;
    RoyalBlue: SKColor;
    SaddleBrown: SKColor;
    Salmon: SKColor;
    SandyBrown: SKColor;
    SeaGreen: SKColor;
    SeaShell: SKColor;
    Sienna: SKColor;
    Silver: SKColor;
    SkyBlue: SKColor;
    SlateBlue: SKColor;
    SlateGray: SKColor;
    Snow: SKColor;
    SpringGreen: SKColor;
    SteelBlue: SKColor;
    Tan: SKColor;
    Teal: SKColor;
    Thistle: SKColor;
    Tomato: SKColor;
    Turquoise: SKColor;
    Violet: SKColor;
    Wheat: SKColor;
    White: SKColor;
    WhiteSmoke: SKColor;
    Yellow: SKColor;
    YellowGreen: SKColor;
    Transparent: SKColor;
    Empty: SKColor;
  }

  export interface SKCubicResampler {
    readonly B: number;
    readonly C: number;
    Equals(obj: SKCubicResampler): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKCubicResampler__statics {
    new(b: number, c: number): SKCubicResampler;
    Mitchell: SKCubicResampler;
    CatmullRom: SKCubicResampler;
  }

  export interface SKData {
    readonly IsEmpty: boolean;
    readonly Size: number;
    readonly Data: number;
    Handle: number;
    Subset(offset: number, length: number): SKData;
    ToArray(): number[];
  }
  export interface SKData__statics {
    Empty: SKData;
    CreateCopy(bytes: number, length: number): SKData;
    CreateCopy(bytes: number, length: number): SKData;
    CreateCopy(bytes: number, length: number): SKData;
    CreateCopy(bytes: number[]): SKData;
    CreateCopy(bytes: number[], length: number): SKData;
    Create(size: number): SKData;
    Create(size: number): SKData;
    Create(size: number): SKData;
    Create(filename: string): SKData;
    Create(stream: SKStream): SKData;
    Create(stream: SKStream, length: number): SKData;
    Create(stream: SKStream, length: number): SKData;
    Create(stream: SKStream, length: number): SKData;
    Create(address: number, length: number): SKData;
    Create(address: number, length: number, releaseProc: SKDataReleaseDelegate): SKData;
    Create(address: number, length: number, releaseProc: SKDataReleaseDelegate, context: any): SKData;
  }

  export type SKDataReleaseDelegate = (address: number, context: any) => void;

  export interface SKDocument {
    Handle: number;
    Abort(): void;
    BeginPage(width: number, height: number): SKCanvas;
    BeginPage(width: number, height: number, content: SKRect): SKCanvas;
    Close(): void;
    EndPage(): void;
  }
  export interface SKDocument__statics {
    DefaultRasterDpi: number;
    CreateXps(path: string): SKDocument;
    CreateXps(stream: SKWStream): SKDocument;
    CreateXps(path: string, dpi: number): SKDocument;
    CreateXps(stream: SKWStream, dpi: number): SKDocument;
    CreatePdf(path: string): SKDocument;
    CreatePdf(stream: SKWStream): SKDocument;
    CreatePdf(path: string, dpi: number): SKDocument;
    CreatePdf(stream: SKWStream, dpi: number): SKDocument;
    CreatePdf(path: string, metadata: SKDocumentPdfMetadata): SKDocument;
    CreatePdf(stream: SKWStream, metadata: SKDocumentPdfMetadata): SKDocument;
  }

  export interface SKDocumentPdfMetadata {
    Title: string;
    Author: string;
    Subject: string;
    Keywords: string;
    Creator: string;
    Producer: string;
    Creation: string | null;
    Modified: string | null;
    RasterDpi: number;
    PdfA: boolean;
    EncodingQuality: number;
    Equals(obj: SKDocumentPdfMetadata): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKDocumentPdfMetadata__statics {
    new(rasterDpi: number): SKDocumentPdfMetadata;
    new(encodingQuality: number): SKDocumentPdfMetadata;
    new(rasterDpi: number, encodingQuality: number): SKDocumentPdfMetadata;
    Default: SKDocumentPdfMetadata;
    DefaultRasterDpi: number;
    DefaultEncodingQuality: number;
  }

  export interface SKDrawable {
    readonly GenerationId: number;
    readonly Bounds: SKRect;
    readonly ApproximateBytesUsed: number;
    Handle: number;
    Draw(canvas: SKCanvas, matrix: Ref<SKMatrix>): void;
    Draw(canvas: SKCanvas, x: number, y: number): void;
    NotifyDrawingChanged(): void;
    Snapshot(): SKPicture;
  }
  export interface SKDynamicMemoryWStream {
    readonly BytesWritten: number;
    Handle: number;
    CopyTo(data: number): void;
    CopyTo(dst: SKWStream): boolean;
    CopyToData(): SKData;
    DetachAsData(): SKData;
    DetachAsStream(): SKStreamAsset;
    Flush(): void;
    NewLine(): boolean;
    Write(buffer: number[], size: number): boolean;
    Write16(value: number): boolean;
    Write32(value: number): boolean;
    Write8(value: number): boolean;
    WriteBigDecimalAsText(value: number, digits: number): boolean;
    WriteBool(value: boolean): boolean;
    WriteDecimalAsTest(value: number): boolean;
    WriteHexAsText(value: number, digits: number): boolean;
    WritePackedUInt32(value: number): boolean;
    WriteScalar(value: number): boolean;
    WriteScalarAsText(value: number): boolean;
    WriteStream(input: SKStream, length: number): boolean;
    WriteText(value: string): boolean;
  }
  export interface SKDynamicMemoryWStream__statics {
    new(): SKDynamicMemoryWStream;
  }

  export enum SKEncodedImageFormat {
    Bmp = 0,
    Gif = 1,
    Ico = 2,
    Jpeg = 3,
    Png = 4,
    Wbmp = 5,
    Webp = 6,
    Pkm = 7,
    Ktx = 8,
    Astc = 9,
    Dng = 10,
    Heif = 11,
    Avif = 12,
    Jpegxl = 13,
  }

  export enum SKEncodedOrigin {
    TopLeft = 1,
    TopRight = 2,
    BottomRight = 3,
    BottomLeft = 4,
    LeftTop = 5,
    RightTop = 6,
    RightBottom = 7,
    LeftBottom = 8,
    Default = 1,
  }

  export interface SKFileStream {
    readonly IsValid: boolean;
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKFileStream__statics {
    new(path: string): SKFileStream;
    IsPathSupported(path: string): boolean;
    OpenStream(path: string): SKStreamAsset;
  }

  export interface SKFileWStream {
    readonly IsValid: boolean;
    readonly BytesWritten: number;
    Handle: number;
    Flush(): void;
    NewLine(): boolean;
    Write(buffer: number[], size: number): boolean;
    Write16(value: number): boolean;
    Write32(value: number): boolean;
    Write8(value: number): boolean;
    WriteBigDecimalAsText(value: number, digits: number): boolean;
    WriteBool(value: boolean): boolean;
    WriteDecimalAsTest(value: number): boolean;
    WriteHexAsText(value: number, digits: number): boolean;
    WritePackedUInt32(value: number): boolean;
    WriteScalar(value: number): boolean;
    WriteScalarAsText(value: number): boolean;
    WriteStream(input: SKStream, length: number): boolean;
    WriteText(value: string): boolean;
  }
  export interface SKFileWStream__statics {
    new(path: string): SKFileWStream;
    IsPathSupported(path: string): boolean;
    OpenStream(path: string): SKWStream;
  }

  export enum SKFilterMode {
    Nearest = 0,
    Linear = 1,
  }

  export enum SKFilterQuality {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
  }

  export interface SKFont {
    ForceAutoHinting: boolean;
    EmbeddedBitmaps: boolean;
    Subpixel: boolean;
    LinearMetrics: boolean;
    Embolden: boolean;
    BaselineSnap: boolean;
    Edging: SKFontEdging;
    Hinting: SKFontHinting;
    Typeface: SKTypeface;
    Size: number;
    ScaleX: number;
    SkewX: number;
    readonly Spacing: number;
    readonly Metrics: SKFontMetrics;
    Handle: number;
    BreakText(text: string, maxWidth: number, paint?: SKPaint): number;
    BreakText(text: string, maxWidth: number, measuredWidth: Out<number>, paint?: SKPaint): number;
    BreakText(text: number, length: number, encoding: SKTextEncoding, maxWidth: number, paint?: SKPaint): number;
    BreakText(text: number, length: number, encoding: SKTextEncoding, maxWidth: number, measuredWidth: Out<number>, paint?: SKPaint): number;
    ContainsGlyph(codepoint: number): boolean;
    ContainsGlyphs(text: string): boolean;
    ContainsGlyphs(text: number, length: number, encoding: SKTextEncoding): boolean;
    CountGlyphs(text: string): number;
    CountGlyphs(text: number, length: number, encoding: SKTextEncoding): number;
    GetFontMetrics(metrics: Out<SKFontMetrics>): number;
    GetGlyph(codepoint: number): number;
    GetGlyphOffsets(text: string, origin?: number): number[];
    GetGlyphOffsets(text: number, length: number, encoding: SKTextEncoding, origin?: number): number[];
    GetGlyphPath(glyph: number): SKPath;
    GetGlyphPositions(text: string, origin?: SKPoint): SKPoint[];
    GetGlyphPositions(text: number, length: number, encoding: SKTextEncoding, origin?: SKPoint): SKPoint[];
    GetGlyphWidths(text: string, paint?: SKPaint): number[];
    GetGlyphWidths(text: string, bounds: Out<SKRect[]>, paint?: SKPaint): number[];
    GetGlyphWidths(text: number, length: number, encoding: SKTextEncoding, paint?: SKPaint): number[];
    GetGlyphWidths(text: number, length: number, encoding: SKTextEncoding, bounds: Out<SKRect[]>, paint?: SKPaint): number[];
    GetGlyphs(text: string): number[];
    GetGlyphs(text: number, length: number, encoding: SKTextEncoding): number[];
    GetTextPath(text: string, origin?: SKPoint): SKPath;
    GetTextPath(text: number, length: number, encoding: SKTextEncoding, origin?: SKPoint): SKPath;
    GetTextPathOnPath(text: string, path: SKPath, textAlign?: SKTextAlign, origin?: SKPoint): SKPath;
    GetTextPathOnPath(text: number, length: number, encoding: SKTextEncoding, path: SKPath, textAlign?: SKTextAlign, origin?: SKPoint): SKPath;
    MeasureText(text: string, paint?: SKPaint): number;
    MeasureText(text: string, bounds: Out<SKRect>, paint?: SKPaint): number;
    MeasureText(text: number, length: number, encoding: SKTextEncoding, paint?: SKPaint): number;
    MeasureText(text: number, length: number, encoding: SKTextEncoding, bounds: Out<SKRect>, paint?: SKPaint): number;
  }
  export interface SKFont__statics {
    new(): SKFont;
    new(typeface: SKTypeface, size?: number, scaleX?: number, skewX?: number): SKFont;
  }

  export enum SKFontEdging {
    Alias = 0,
    Antialias = 1,
    SubpixelAntialias = 2,
  }

  export enum SKFontHinting {
    None = 0,
    Slight = 1,
    Normal = 2,
    Full = 3,
  }

  export interface SKFontManager {
    readonly FontFamilyCount: number;
    readonly FontFamilies: string[];
    Handle: number;
    CreateTypeface(data: SKData, index?: number): SKTypeface;
    CreateTypeface(path: string, index?: number): SKTypeface;
    CreateTypeface(stream: SKStreamAsset, index?: number): SKTypeface;
    GetFamilyName(index: number): string;
    GetFontFamilies(): string[];
    GetFontStyles(index: number): SKFontStyle[];
    GetFontStyles(familyName: string): SKFontStyle[];
    MatchCharacter(character: number): SKTypeface;
    MatchCharacter(character: string): SKTypeface;
    MatchCharacter(familyName: string, character: string): SKTypeface;
    MatchCharacter(familyName: string, character: number): SKTypeface;
    MatchCharacter(familyName: string, bcp47: string[], character: string): SKTypeface;
    MatchCharacter(familyName: string, bcp47: string[], character: number): SKTypeface;
    MatchCharacter(familyName: string, style: SKFontStyle, bcp47: string[], character: number): SKTypeface;
    MatchCharacter(familyName: string, weight: number, width: number, slant: SKFontStyleSlant, bcp47: string[], character: number): SKTypeface;
    MatchCharacter(familyName: string, weight: SKFontStyleWeight, width: SKFontStyleWidth, slant: SKFontStyleSlant, bcp47: string[], character: string): SKTypeface;
    MatchCharacter(familyName: string, weight: SKFontStyleWeight, width: SKFontStyleWidth, slant: SKFontStyleSlant, bcp47: string[], character: number): SKTypeface;
    MatchFamily(familyName: string): SKTypeface;
    MatchFamily(familyName: string, style: SKFontStyle): SKTypeface;
  }
  export interface SKFontManager__statics {
    Default: SKFontManager;
    CreateDefault(): SKFontManager;
  }

  export interface SKFontMetrics {
    readonly Top: number;
    readonly Ascent: number;
    readonly Descent: number;
    readonly Bottom: number;
    readonly Leading: number;
    readonly AverageCharacterWidth: number;
    readonly MaxCharacterWidth: number;
    readonly XMin: number;
    readonly XMax: number;
    readonly XHeight: number;
    readonly CapHeight: number;
    readonly UnderlineThickness: number | null;
    readonly UnderlinePosition: number | null;
    readonly StrikeoutThickness: number | null;
    readonly StrikeoutPosition: number | null;
    Equals(obj: SKFontMetrics): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKFontStyle {
    readonly Weight: number;
    readonly Width: number;
    readonly Slant: SKFontStyleSlant;
    Handle: number;
  }
  export interface SKFontStyle__statics {
    new(): SKFontStyle;
    new(weight: SKFontStyleWeight, width: SKFontStyleWidth, slant: SKFontStyleSlant): SKFontStyle;
    new(weight: number, width: number, slant: SKFontStyleSlant): SKFontStyle;
    Normal: SKFontStyle;
    Bold: SKFontStyle;
    Italic: SKFontStyle;
    BoldItalic: SKFontStyle;
  }

  export interface SKFontStyleSet {
    readonly Count: number;
    get_Item(index: number): SKFontStyle;
    Handle: number;
    CreateTypeface(index: number): SKTypeface;
    CreateTypeface(style: SKFontStyle): SKTypeface;
    GetStyleName(index: number): string;
  }
  export interface SKFontStyleSet__statics {
    new(): SKFontStyleSet;
  }

  export enum SKFontStyleSlant {
    Upright = 0,
    Italic = 1,
    Oblique = 2,
  }

  export enum SKFontStyleWeight {
    Invisible = 0,
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Normal = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    ExtraBold = 800,
    Black = 900,
    ExtraBlack = 1000,
  }

  export enum SKFontStyleWidth {
    UltraCondensed = 1,
    ExtraCondensed = 2,
    Condensed = 3,
    SemiCondensed = 4,
    Normal = 5,
    SemiExpanded = 6,
    Expanded = 7,
    ExtraExpanded = 8,
    UltraExpanded = 9,
  }

  export interface SKFrontBufferedManagedStream {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKFrontBufferedManagedStream__statics {
    new(nativeStream: SKStream, bufferSize: number): SKFrontBufferedManagedStream;
    new(nativeStream: SKStream, bufferSize: number, disposeUnderlyingStream: boolean): SKFrontBufferedManagedStream;
  }

  export type SKGlyphPathDelegate = (path: SKPath, matrix: SKMatrix) => void;

  export interface SKGraphics {
  }
  export interface SKGraphics__statics {
    Init(): void;
    PurgeFontCache(): void;
    PurgeResourceCache(): void;
    PurgeAllCaches(): void;
    GetFontCacheUsed(): number;
    GetFontCacheLimit(): number;
    SetFontCacheLimit(bytes: number): number;
    GetFontCacheCountUsed(): number;
    GetFontCacheCountLimit(): number;
    SetFontCacheCountLimit(count: number): number;
    GetResourceCacheTotalBytesUsed(): number;
    GetResourceCacheTotalByteLimit(): number;
    SetResourceCacheTotalByteLimit(bytes: number): number;
    GetResourceCacheSingleAllocationByteLimit(): number;
    SetResourceCacheSingleAllocationByteLimit(bytes: number): number;
    DumpMemoryStatistics(dump: SKTraceMemoryDump): void;
  }

  export interface SKHighContrastConfig {
    readonly IsValid: boolean;
    Grayscale: boolean;
    InvertStyle: SKHighContrastConfigInvertStyle;
    Contrast: number;
    Equals(obj: SKHighContrastConfig): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKHighContrastConfig__statics {
    new(grayscale: boolean, invertStyle: SKHighContrastConfigInvertStyle, contrast: number): SKHighContrastConfig;
    Default: SKHighContrastConfig;
  }

  export enum SKHighContrastConfigInvertStyle {
    NoInvert = 0,
    InvertBrightness = 1,
    InvertLightness = 2,
  }

  export interface SKHorizontalRunBuffer {
    readonly Size: number;
  }
  export interface SKHorizontalTextRunBuffer {
    readonly TextSize: number;
    readonly Size: number;
  }
  export interface SKImage {
    readonly Width: number;
    readonly Height: number;
    readonly UniqueId: number;
    readonly AlphaType: SKAlphaType;
    readonly ColorType: SKColorType;
    readonly ColorSpace: SKColorSpace;
    readonly IsAlphaOnly: boolean;
    readonly EncodedData: SKData;
    readonly Info: SKImageInfo;
    readonly IsTextureBacked: boolean;
    readonly IsLazyGenerated: boolean;
    Handle: number;
    ApplyImageFilter(filter: SKImageFilter, subset: SKRectI, clipBounds: SKRectI, outSubset: Out<SKRectI>, outOffset: Out<SKPointI>): SKImage;
    ApplyImageFilter(filter: SKImageFilter, subset: SKRectI, clipBounds: SKRectI, outSubset: Out<SKRectI>, outOffset: Out<SKPoint>): SKImage;
    ApplyImageFilter(context: GRRecordingContext, filter: SKImageFilter, subset: SKRectI, clipBounds: SKRectI, outSubset: Out<SKRectI>, outOffset: Out<SKPointI>): SKImage;
    ApplyImageFilter(context: GRContext, filter: SKImageFilter, subset: SKRectI, clipBounds: SKRectI, outSubset: Out<SKRectI>, outOffset: Out<SKPointI>): SKImage;
    Encode(): SKData;
    Encode(format: SKEncodedImageFormat, quality: number): SKData;
    IsValid(context: GRRecordingContext): boolean;
    IsValid(context: GRContext): boolean;
    PeekPixels(): SKPixmap;
    PeekPixels(pixmap: SKPixmap): boolean;
    ReadPixels(pixmap: SKPixmap): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number): boolean;
    ReadPixels(pixmap: SKPixmap, srcX: number, srcY: number): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number): boolean;
    ReadPixels(pixmap: SKPixmap, srcX: number, srcY: number, cachingHint: SKImageCachingHint): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number, srcX: number, srcY: number): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number, srcX: number, srcY: number, cachingHint: SKImageCachingHint): boolean;
    ScalePixels(dst: SKPixmap, quality: SKFilterQuality): boolean;
    ScalePixels(dst: SKPixmap, sampling: SKSamplingOptions): boolean;
    ScalePixels(dst: SKPixmap, quality: SKFilterQuality, cachingHint: SKImageCachingHint): boolean;
    ScalePixels(dst: SKPixmap, sampling: SKSamplingOptions, cachingHint: SKImageCachingHint): boolean;
    Subset(subset: SKRectI): SKImage;
    Subset(context: GRRecordingContext, subset: SKRectI): SKImage;
    ToRasterImage(): SKImage;
    ToRasterImage(ensurePixelData: boolean): SKImage;
    ToRawShader(): SKShader;
    ToRawShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode): SKShader;
    ToRawShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, sampling: SKSamplingOptions): SKShader;
    ToRawShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    ToRawShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, sampling: SKSamplingOptions, localMatrix: SKMatrix): SKShader;
    ToShader(): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, quality: SKFilterQuality): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, sampling: SKSamplingOptions): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, sampling: SKSamplingOptions, localMatrix: SKMatrix): SKShader;
    ToShader(tileX: SKShaderTileMode, tileY: SKShaderTileMode, quality: SKFilterQuality, localMatrix: SKMatrix): SKShader;
    ToTextureImage(context: GRContext): SKImage;
    ToTextureImage(context: GRContext, mipmapped: boolean): SKImage;
    ToTextureImage(context: GRContext, mipmapped: boolean, budgeted: boolean): SKImage;
  }
  export interface SKImage__statics {
    Create(info: SKImageInfo): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: SKStream): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: SKStream, rowBytes: number): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: number[]): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: number[], rowBytes: number): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: number): SKImage;
    FromPixelCopy(info: SKImageInfo, pixels: number, rowBytes: number): SKImage;
    FromPixelCopy(pixmap: SKPixmap): SKImage;
    FromPixels(info: SKImageInfo, data: SKData): SKImage;
    FromPixels(info: SKImageInfo, data: SKData, rowBytes: number): SKImage;
    FromPixels(info: SKImageInfo, pixels: number): SKImage;
    FromPixels(info: SKImageInfo, pixels: number, rowBytes: number): SKImage;
    FromPixels(pixmap: SKPixmap): SKImage;
    FromPixels(pixmap: SKPixmap, releaseProc: SKImageRasterReleaseDelegate): SKImage;
    FromPixels(pixmap: SKPixmap, releaseProc: SKImageRasterReleaseDelegate, releaseContext: any): SKImage;
    FromEncodedData(data: SKData, subset: SKRectI): SKImage;
    FromEncodedData(data: SKData): SKImage;
    FromEncodedData(data: number[]): SKImage;
    FromEncodedData(data: SKStream): SKImage;
    FromEncodedData(filename: string): SKImage;
    FromBitmap(bitmap: SKBitmap): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, colorType: SKColorType): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace, releaseProc: SKImageTextureReleaseDelegate): SKImage;
    FromTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace, releaseProc: SKImageTextureReleaseDelegate, releaseContext: any): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, colorType: SKColorType): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace, releaseProc: SKImageTextureReleaseDelegate): SKImage;
    FromTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace, releaseProc: SKImageTextureReleaseDelegate, releaseContext: any): SKImage;
    FromAdoptedTexture(context: GRContext, texture: GRBackendTexture, colorType: SKColorType): SKImage;
    FromAdoptedTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKImage;
    FromAdoptedTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType): SKImage;
    FromAdoptedTexture(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace): SKImage;
    FromAdoptedTexture(context: GRRecordingContext, texture: GRBackendTexture, colorType: SKColorType): SKImage;
    FromAdoptedTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKImage;
    FromAdoptedTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType): SKImage;
    FromAdoptedTexture(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, alpha: SKAlphaType, colorspace: SKColorSpace): SKImage;
    FromPicture(picture: SKPicture, dimensions: SKSizeI): SKImage;
    FromPicture(picture: SKPicture, dimensions: SKSizeI, matrix: SKMatrix): SKImage;
    FromPicture(picture: SKPicture, dimensions: SKSizeI, paint: SKPaint): SKImage;
    FromPicture(picture: SKPicture, dimensions: SKSizeI, matrix: SKMatrix, paint: SKPaint): SKImage;
  }

  export enum SKImageCachingHint {
    Allow = 0,
    Disallow = 1,
  }

  export interface SKImageFilter {
    Handle: number;
  }
  export interface SKImageFilter__statics {
    CreateMatrix(matrix: SKMatrix): SKImageFilter;
    CreateMatrix(matrix: SKMatrix, quality: SKFilterQuality, input: SKImageFilter): SKImageFilter;
    CreateMatrix(matrix: Ref<SKMatrix>): SKImageFilter;
    CreateMatrix(matrix: Ref<SKMatrix>, sampling: SKSamplingOptions): SKImageFilter;
    CreateMatrix(matrix: Ref<SKMatrix>, sampling: SKSamplingOptions, input: SKImageFilter): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number, input: SKImageFilter): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number, tileMode: SKShaderTileMode): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number, tileMode: SKShaderTileMode, input: SKImageFilter): SKImageFilter;
    CreateBlur(sigmaX: number, sigmaY: number, tileMode: SKShaderTileMode, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateColorFilter(cf: SKColorFilter): SKImageFilter;
    CreateColorFilter(cf: SKColorFilter, input: SKImageFilter): SKImageFilter;
    CreateColorFilter(cf: SKColorFilter, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateCompose(outer: SKImageFilter, inner: SKImageFilter): SKImageFilter;
    CreateDisplacementMapEffect(xChannelSelector: SKColorChannel, yChannelSelector: SKColorChannel, scale: number, displacement: SKImageFilter): SKImageFilter;
    CreateDisplacementMapEffect(xChannelSelector: SKColorChannel, yChannelSelector: SKColorChannel, scale: number, displacement: SKImageFilter, input: SKImageFilter): SKImageFilter;
    CreateDisplacementMapEffect(xChannelSelector: SKColorChannel, yChannelSelector: SKColorChannel, scale: number, displacement: SKImageFilter, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateDropShadow(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor): SKImageFilter;
    CreateDropShadow(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor, input: SKImageFilter): SKImageFilter;
    CreateDropShadow(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateDropShadowOnly(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor): SKImageFilter;
    CreateDropShadowOnly(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor, input: SKImageFilter): SKImageFilter;
    CreateDropShadowOnly(dx: number, dy: number, sigmaX: number, sigmaY: number, color: SKColor, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateDistantLitDiffuse(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number): SKImageFilter;
    CreateDistantLitDiffuse(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter): SKImageFilter;
    CreateDistantLitDiffuse(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreatePointLitDiffuse(location: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number): SKImageFilter;
    CreatePointLitDiffuse(location: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter): SKImageFilter;
    CreatePointLitDiffuse(location: SKPoint3, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateSpotLitDiffuse(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, kd: number): SKImageFilter;
    CreateSpotLitDiffuse(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter): SKImageFilter;
    CreateSpotLitDiffuse(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, kd: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateDistantLitSpecular(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number): SKImageFilter;
    CreateDistantLitSpecular(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter): SKImageFilter;
    CreateDistantLitSpecular(direction: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreatePointLitSpecular(location: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number): SKImageFilter;
    CreatePointLitSpecular(location: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter): SKImageFilter;
    CreatePointLitSpecular(location: SKPoint3, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateSpotLitSpecular(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number): SKImageFilter;
    CreateSpotLitSpecular(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter): SKImageFilter;
    CreateSpotLitSpecular(location: SKPoint3, target: SKPoint3, specularExponent: number, cutoffAngle: number, lightColor: SKColor, surfaceScale: number, ks: number, shininess: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateMerge(first: SKImageFilter, second: SKImageFilter): SKImageFilter;
    CreateMerge(first: SKImageFilter, second: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateDilate(radiusX: number, radiusY: number): SKImageFilter;
    CreateDilate(radiusX: number, radiusY: number, input: SKImageFilter): SKImageFilter;
    CreateDilate(radiusX: number, radiusY: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateErode(radiusX: number, radiusY: number): SKImageFilter;
    CreateErode(radiusX: number, radiusY: number, input: SKImageFilter): SKImageFilter;
    CreateErode(radiusX: number, radiusY: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateOffset(radiusX: number, radiusY: number): SKImageFilter;
    CreateOffset(radiusX: number, radiusY: number, input: SKImageFilter): SKImageFilter;
    CreateOffset(radiusX: number, radiusY: number, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreatePicture(picture: SKPicture): SKImageFilter;
    CreatePicture(picture: SKPicture, cropRect: SKRect): SKImageFilter;
    CreateTile(src: SKRect, dst: SKRect): SKImageFilter;
    CreateTile(src: SKRect, dst: SKRect, input: SKImageFilter): SKImageFilter;
    CreateBlendMode(mode: SKBlendMode, background: SKImageFilter): SKImageFilter;
    CreateBlendMode(mode: SKBlendMode, background: SKImageFilter, foreground: SKImageFilter): SKImageFilter;
    CreateBlendMode(mode: SKBlendMode, background: SKImageFilter, foreground: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateBlendMode(blender: SKBlender, background: SKImageFilter): SKImageFilter;
    CreateBlendMode(blender: SKBlender, background: SKImageFilter, foreground: SKImageFilter): SKImageFilter;
    CreateBlendMode(blender: SKBlender, background: SKImageFilter, foreground: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateArithmetic(k1: number, k2: number, k3: number, k4: number, enforcePMColor: boolean, background: SKImageFilter): SKImageFilter;
    CreateArithmetic(k1: number, k2: number, k3: number, k4: number, enforcePMColor: boolean, background: SKImageFilter, foreground: SKImageFilter): SKImageFilter;
    CreateArithmetic(k1: number, k2: number, k3: number, k4: number, enforcePMColor: boolean, background: SKImageFilter, foreground: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreateImage(image: SKImage): SKImageFilter;
    CreateImage(image: SKImage, sampling: SKSamplingOptions): SKImageFilter;
    CreateImage(image: SKImage, src: SKRect, dst: SKRect, sampling: SKSamplingOptions): SKImageFilter;
    CreateImage(image: SKImage, src: SKRect, dst: SKRect, filterQuality: SKFilterQuality): SKImageFilter;
    CreateMagnifier(lensBounds: SKRect, zoomAmount: number, inset: number, sampling: SKSamplingOptions): SKImageFilter;
    CreateMagnifier(lensBounds: SKRect, zoomAmount: number, inset: number, sampling: SKSamplingOptions, input: SKImageFilter): SKImageFilter;
    CreateMagnifier(lensBounds: SKRect, zoomAmount: number, inset: number, sampling: SKSamplingOptions, input: SKImageFilter, cropRect: SKRect): SKImageFilter;
    CreatePaint(paint: SKPaint): SKImageFilter;
    CreatePaint(paint: SKPaint, cropRect: SKRect): SKImageFilter;
    CreateShader(shader: SKShader): SKImageFilter;
    CreateShader(shader: SKShader, dither: boolean): SKImageFilter;
    CreateShader(shader: SKShader, dither: boolean, cropRect: SKRect): SKImageFilter;
  }

  export interface SKImageInfo {
    Width: number;
    Height: number;
    ColorType: SKColorType;
    AlphaType: SKAlphaType;
    ColorSpace: SKColorSpace;
    readonly BytesPerPixel: number;
    readonly BitShiftPerPixel: number;
    readonly BitsPerPixel: number;
    readonly BytesSize: number;
    readonly BytesSize64: number;
    readonly RowBytes: number;
    readonly RowBytes64: number;
    readonly IsEmpty: boolean;
    readonly IsOpaque: boolean;
    readonly Size: SKSizeI;
    readonly Rect: SKRectI;
    Equals(obj: SKImageInfo): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    WithAlphaType(newAlphaType: SKAlphaType): SKImageInfo;
    WithColorSpace(newColorSpace: SKColorSpace): SKImageInfo;
    WithColorType(newColorType: SKColorType): SKImageInfo;
    WithSize(size: SKSizeI): SKImageInfo;
    WithSize(width: number, height: number): SKImageInfo;
  }
  export interface SKImageInfo__statics {
    new(width: number, height: number): SKImageInfo;
    new(width: number, height: number, colorType: SKColorType): SKImageInfo;
    new(width: number, height: number, colorType: SKColorType, alphaType: SKAlphaType): SKImageInfo;
    new(width: number, height: number, colorType: SKColorType, alphaType: SKAlphaType, colorspace: SKColorSpace): SKImageInfo;
    Empty: SKImageInfo;
    PlatformColorType: SKColorType;
    PlatformColorAlphaShift: number;
    PlatformColorRedShift: number;
    PlatformColorGreenShift: number;
    PlatformColorBlueShift: number;
  }

  export type SKImageRasterReleaseDelegate = (pixels: number, context: any) => void;

  export type SKImageTextureReleaseDelegate = (context: any) => void;

  export enum SKJpegEncoderAlphaOption {
    Ignore = 0,
    BlendOnBlack = 1,
  }

  export enum SKJpegEncoderDownsample {
    Downsample420 = 0,
    Downsample422 = 1,
    Downsample444 = 2,
  }

  export interface SKJpegEncoderOptions {
    readonly AlphaOption: SKJpegEncoderAlphaOption;
    readonly Downsample: SKJpegEncoderDownsample;
    readonly Quality: number;
    Equals(obj: SKJpegEncoderOptions): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKJpegEncoderOptions__statics {
    new(quality: number): SKJpegEncoderOptions;
    new(quality: number, downsample: SKJpegEncoderDownsample, alphaOption: SKJpegEncoderAlphaOption): SKJpegEncoderOptions;
    Default: SKJpegEncoderOptions;
  }

  export interface SKLattice {
    XDivs: number[];
    YDivs: number[];
    RectTypes: SKLatticeRectType[];
    Bounds: SKRectI | null;
    Colors: SKColor[];
    Equals(obj: SKLattice): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export enum SKLatticeRectType {
    Default = 0,
    Transparent = 1,
    FixedColor = 2,
  }

  export interface SKManagedStream {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    CopyTo(destination: SKWStream): number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
    ToMemoryStream(): SKStreamAsset;
  }
  export interface SKManagedWStream {
    readonly BytesWritten: number;
    Handle: number;
    Flush(): void;
    NewLine(): boolean;
    Write(buffer: number[], size: number): boolean;
    Write16(value: number): boolean;
    Write32(value: number): boolean;
    Write8(value: number): boolean;
    WriteBigDecimalAsText(value: number, digits: number): boolean;
    WriteBool(value: boolean): boolean;
    WriteDecimalAsTest(value: number): boolean;
    WriteHexAsText(value: number, digits: number): boolean;
    WritePackedUInt32(value: number): boolean;
    WriteScalar(value: number): boolean;
    WriteScalarAsText(value: number): boolean;
    WriteStream(input: SKStream, length: number): boolean;
    WriteText(value: string): boolean;
  }
  export interface SKMaskFilter {
    Handle: number;
  }
  export interface SKMaskFilter__statics {
    TableMaxLength: number;
    ConvertRadiusToSigma(radius: number): number;
    ConvertSigmaToRadius(sigma: number): number;
    CreateBlur(blurStyle: SKBlurStyle, sigma: number): SKMaskFilter;
    CreateBlur(blurStyle: SKBlurStyle, sigma: number, respectCTM: boolean): SKMaskFilter;
    CreateTable(table: number[]): SKMaskFilter;
    CreateGamma(gamma: number): SKMaskFilter;
    CreateClip(min: number, max: number): SKMaskFilter;
  }

  export interface SKMatrix {
    ScaleX: number;
    SkewX: number;
    TransX: number;
    SkewY: number;
    ScaleY: number;
    TransY: number;
    Persp0: number;
    Persp1: number;
    Persp2: number;
    readonly IsIdentity: boolean;
    Values: number[];
    readonly IsInvertible: boolean;
    Equals(obj: SKMatrix): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    GetValues(values: number[]): void;
    Invert(): SKMatrix;
    MapPoint(point: SKPoint): SKPoint;
    MapPoint(x: number, y: number): SKPoint;
    MapPoints(points: SKPoint[]): SKPoint[];
    MapPoints(result: SKPoint[], points: SKPoint[]): void;
    MapRadius(radius: number): number;
    MapRect(source: SKRect): SKRect;
    MapVector(vector: SKPoint): SKPoint;
    MapVector(x: number, y: number): SKPoint;
    MapVectors(vectors: SKPoint[]): SKPoint[];
    MapVectors(result: SKPoint[], vectors: SKPoint[]): void;
    PostConcat(matrix: SKMatrix): SKMatrix;
    PreConcat(matrix: SKMatrix): SKMatrix;
    TryInvert(inverse: Out<SKMatrix>): boolean;
  }
  export interface SKMatrix__statics {
    new(values: number[]): SKMatrix;
    new(scaleX: number, skewX: number, transX: number, skewY: number, scaleY: number, transY: number, persp0: number, persp1: number, persp2: number): SKMatrix;
    Empty: SKMatrix;
    Identity: SKMatrix;
    CreateIdentity(): SKMatrix;
    CreateTranslation(x: number, y: number): SKMatrix;
    CreateScale(x: number, y: number): SKMatrix;
    CreateScale(x: number, y: number, pivotX: number, pivotY: number): SKMatrix;
    CreateRotation(radians: number): SKMatrix;
    CreateRotation(radians: number, pivotX: number, pivotY: number): SKMatrix;
    CreateRotationDegrees(degrees: number): SKMatrix;
    CreateRotationDegrees(degrees: number, pivotX: number, pivotY: number): SKMatrix;
    CreateSkew(x: number, y: number): SKMatrix;
    CreateScaleTranslation(sx: number, sy: number, tx: number, ty: number): SKMatrix;
    Concat(first: SKMatrix, second: SKMatrix): SKMatrix;
    Concat(target: Ref<SKMatrix>, first: SKMatrix, second: SKMatrix): void;
  }

  export interface SKMatrix44 {
    M00: number;
    M01: number;
    M02: number;
    M03: number;
    M10: number;
    M11: number;
    M12: number;
    M13: number;
    M20: number;
    M21: number;
    M22: number;
    M23: number;
    M30: number;
    M31: number;
    M32: number;
    M33: number;
    readonly IsInvertible: boolean;
    readonly Matrix: SKMatrix;
    get_Item(row: number, column: number): number;
    Determinant(): number;
    Equals(obj: SKMatrix44): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Invert(): SKMatrix44;
    MapPoint(point: SKPoint): SKPoint;
    MapPoint(point: SKPoint3): SKPoint3;
    MapPoint(x: number, y: number): SKPoint;
    MapPoint(x: number, y: number, z: number): SKPoint3;
    PostConcat(matrix: SKMatrix44): SKMatrix44;
    PreConcat(matrix: SKMatrix44): SKMatrix44;
    ToColumnMajor(): number[];
    ToRowMajor(): number[];
    Transpose(): SKMatrix44;
    TryInvert(inverse: Out<SKMatrix44>): boolean;
  }
  export interface SKMatrix44__statics {
    new(): SKMatrix44;
    new(src: SKMatrix): SKMatrix44;
    new(src: SKMatrix44): SKMatrix44;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): SKMatrix44;
    Empty: SKMatrix44;
    Identity: SKMatrix44;
    CreateIdentity(): SKMatrix44;
    CreateTranslation(x: number, y: number, z: number): SKMatrix44;
    CreateScale(x: number, y: number, z: number): SKMatrix44;
    CreateScale(x: number, y: number, z: number, pivotX: number, pivotY: number, pivotZ: number): SKMatrix44;
    CreateRotation(x: number, y: number, z: number, radians: number): SKMatrix44;
    CreateRotationDegrees(x: number, y: number, z: number, degrees: number): SKMatrix44;
    Concat(first: SKMatrix44, second: SKMatrix44): SKMatrix44;
    Concat(target: Ref<SKMatrix44>, first: SKMatrix44, second: SKMatrix44): void;
    Negate(value: SKMatrix44): SKMatrix44;
    Add(value1: SKMatrix44, value2: SKMatrix44): SKMatrix44;
    Subtract(value1: SKMatrix44, value2: SKMatrix44): SKMatrix44;
    Multiply(value1: SKMatrix44, value2: SKMatrix44): SKMatrix44;
    Multiply(value1: SKMatrix44, value2: number): SKMatrix44;
  }

  export interface SKMemoryStream {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    SetMemory(data: number[]): void;
    Skip(size: number): number;
  }
  export interface SKMemoryStream__statics {
    new(): SKMemoryStream;
    new(length: number): SKMemoryStream;
    new(data: SKData): SKMemoryStream;
    new(data: number[]): SKMemoryStream;
  }

  export enum SKMipmapMode {
    None = 0,
    Nearest = 1,
    Linear = 2,
  }

  export interface SKNWayCanvas {
    readonly LocalClipBounds: SKRect;
    readonly DeviceClipBounds: SKRectI;
    readonly IsClipEmpty: boolean;
    readonly IsClipRect: boolean;
    readonly Surface: SKSurface;
    readonly Context: GRRecordingContext;
    readonly TotalMatrix: SKMatrix;
    readonly TotalMatrix44: SKMatrix44;
    readonly SaveCount: number;
    Handle: number;
    AddCanvas(canvas: SKCanvas): void;
    Clear(): void;
    Clear(color: SKColorF): void;
    Clear(color: SKColor): void;
    ClipPath(path: SKPath, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRect(rect: SKRect, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRegion(region: SKRegion, operation?: SKClipOperation): void;
    ClipRoundRect(rect: SKRoundRect, operation?: SKClipOperation, antialias?: boolean): void;
    Concat(m: Ref<SKMatrix44>): void;
    Concat(m: Ref<SKMatrix>): void;
    Discard(): void;
    DrawAnnotation(rect: SKRect, key: string, value: SKData): void;
    DrawArc(oval: SKRect, startAngle: number, sweepAngle: number, useCenter: boolean, paint: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, cullRect: SKRect, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, cullRect: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, p: SKPoint, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, x: number, y: number, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawCircle(c: SKPoint, radius: number, paint: SKPaint): void;
    DrawCircle(cx: number, cy: number, radius: number, paint: SKPaint): void;
    DrawColor(color: SKColorF, mode?: SKBlendMode): void;
    DrawColor(color: SKColor, mode?: SKBlendMode): void;
    DrawDrawable(drawable: SKDrawable, matrix: Ref<SKMatrix>): void;
    DrawDrawable(drawable: SKDrawable, p: SKPoint): void;
    DrawDrawable(drawable: SKDrawable, x: number, y: number): void;
    DrawImage(image: SKImage, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, filterMode?: SKFilterMode, paint?: SKPaint): void;
    DrawLine(p0: SKPoint, p1: SKPoint, paint: SKPaint): void;
    DrawLine(x0: number, y0: number, x1: number, y1: number, paint: SKPaint): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: SKData): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: string): SKData;
    DrawNamedDestinationAnnotation(point: SKPoint, value: SKData): void;
    DrawNamedDestinationAnnotation(point: SKPoint, value: string): SKData;
    DrawOval(rect: SKRect, paint: SKPaint): void;
    DrawOval(c: SKPoint, r: SKSize, paint: SKPaint): void;
    DrawOval(cx: number, cy: number, rx: number, ry: number, paint: SKPaint): void;
    DrawPaint(paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], mode: SKBlendMode, paint: SKPaint): void;
    DrawPath(path: SKPath, paint: SKPaint): void;
    DrawPicture(picture: SKPicture, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, matrix: Ref<SKMatrix>, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, p: SKPoint, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, x: number, y: number, paint?: SKPaint): void;
    DrawPoint(p: SKPoint, color: SKColor): void;
    DrawPoint(p: SKPoint, paint: SKPaint): void;
    DrawPoint(x: number, y: number, color: SKColor): void;
    DrawPoint(x: number, y: number, paint: SKPaint): void;
    DrawPoints(mode: SKPointMode, points: SKPoint[], paint: SKPaint): void;
    DrawRect(rect: SKRect, paint: SKPaint): void;
    DrawRect(x: number, y: number, w: number, h: number, paint: SKPaint): void;
    DrawRegion(region: SKRegion, paint: SKPaint): void;
    DrawRoundRect(rect: SKRoundRect, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, r: SKSize, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRect(x: number, y: number, w: number, h: number, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRectDifference(outer: SKRoundRect, inner: SKRoundRect, paint: SKPaint): void;
    DrawSurface(surface: SKSurface, p: SKPoint, paint?: SKPaint): void;
    DrawSurface(surface: SKSurface, x: number, y: number, paint?: SKPaint): void;
    DrawText(text: string, p: SKPoint, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, paint: SKPaint): void;
    DrawText(text: SKTextBlob, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawUrlAnnotation(rect: SKRect, value: string): SKData;
    DrawUrlAnnotation(rect: SKRect, value: SKData): void;
    DrawVertices(vertices: SKVertices, mode: SKBlendMode, paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], indices: number[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], mode: SKBlendMode, indices: number[], paint: SKPaint): void;
    Flush(): void;
    GetDeviceClipBounds(bounds: Out<SKRectI>): boolean;
    GetLocalClipBounds(bounds: Out<SKRect>): boolean;
    QuickReject(path: SKPath): boolean;
    QuickReject(rect: SKRect): boolean;
    RemoveAll(): void;
    RemoveCanvas(canvas: SKCanvas): void;
    ResetMatrix(): void;
    Restore(): void;
    RestoreToCount(count: number): void;
    RotateDegrees(degrees: number): void;
    RotateDegrees(degrees: number, px: number, py: number): void;
    RotateRadians(radians: number): void;
    RotateRadians(radians: number, px: number, py: number): void;
    Save(): number;
    SaveLayer(): number;
    SaveLayer(paint: SKPaint): number;
    SaveLayer(rec: Ref<SKCanvasSaveLayerRec>): number;
    SaveLayer(limit: SKRect, paint: SKPaint): number;
    Scale(s: number): void;
    Scale(size: SKPoint): void;
    Scale(sx: number, sy: number): void;
    Scale(sx: number, sy: number, px: number, py: number): void;
    SetMatrix(matrix: SKMatrix): void;
    SetMatrix(matrix: Ref<SKMatrix44>): void;
    SetMatrix(matrix: Ref<SKMatrix>): void;
    Skew(skew: SKPoint): void;
    Skew(sx: number, sy: number): void;
    Translate(point: SKPoint): void;
    Translate(dx: number, dy: number): void;
  }
  export interface SKNWayCanvas__statics {
    new(width: number, height: number): SKNWayCanvas;
  }

  export interface SKNativeObject {
    Handle: number;
  }
  export interface SKNoDrawCanvas {
    readonly LocalClipBounds: SKRect;
    readonly DeviceClipBounds: SKRectI;
    readonly IsClipEmpty: boolean;
    readonly IsClipRect: boolean;
    readonly Surface: SKSurface;
    readonly Context: GRRecordingContext;
    readonly TotalMatrix: SKMatrix;
    readonly TotalMatrix44: SKMatrix44;
    readonly SaveCount: number;
    Handle: number;
    Clear(): void;
    Clear(color: SKColorF): void;
    Clear(color: SKColor): void;
    ClipPath(path: SKPath, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRect(rect: SKRect, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRegion(region: SKRegion, operation?: SKClipOperation): void;
    ClipRoundRect(rect: SKRoundRect, operation?: SKClipOperation, antialias?: boolean): void;
    Concat(m: Ref<SKMatrix>): void;
    Concat(m: Ref<SKMatrix44>): void;
    Discard(): void;
    DrawAnnotation(rect: SKRect, key: string, value: SKData): void;
    DrawArc(oval: SKRect, startAngle: number, sweepAngle: number, useCenter: boolean, paint: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, cullRect: SKRect, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, cullRect: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, p: SKPoint, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, x: number, y: number, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawCircle(c: SKPoint, radius: number, paint: SKPaint): void;
    DrawCircle(cx: number, cy: number, radius: number, paint: SKPaint): void;
    DrawColor(color: SKColor, mode?: SKBlendMode): void;
    DrawColor(color: SKColorF, mode?: SKBlendMode): void;
    DrawDrawable(drawable: SKDrawable, p: SKPoint): void;
    DrawDrawable(drawable: SKDrawable, matrix: Ref<SKMatrix>): void;
    DrawDrawable(drawable: SKDrawable, x: number, y: number): void;
    DrawImage(image: SKImage, p: SKPoint, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, filterMode?: SKFilterMode, paint?: SKPaint): void;
    DrawLine(p0: SKPoint, p1: SKPoint, paint: SKPaint): void;
    DrawLine(x0: number, y0: number, x1: number, y1: number, paint: SKPaint): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: SKData): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: string): SKData;
    DrawNamedDestinationAnnotation(point: SKPoint, value: SKData): void;
    DrawNamedDestinationAnnotation(point: SKPoint, value: string): SKData;
    DrawOval(rect: SKRect, paint: SKPaint): void;
    DrawOval(c: SKPoint, r: SKSize, paint: SKPaint): void;
    DrawOval(cx: number, cy: number, rx: number, ry: number, paint: SKPaint): void;
    DrawPaint(paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], mode: SKBlendMode, paint: SKPaint): void;
    DrawPath(path: SKPath, paint: SKPaint): void;
    DrawPicture(picture: SKPicture, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, p: SKPoint, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, matrix: Ref<SKMatrix>, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, x: number, y: number, paint?: SKPaint): void;
    DrawPoint(p: SKPoint, color: SKColor): void;
    DrawPoint(p: SKPoint, paint: SKPaint): void;
    DrawPoint(x: number, y: number, color: SKColor): void;
    DrawPoint(x: number, y: number, paint: SKPaint): void;
    DrawPoints(mode: SKPointMode, points: SKPoint[], paint: SKPaint): void;
    DrawRect(rect: SKRect, paint: SKPaint): void;
    DrawRect(x: number, y: number, w: number, h: number, paint: SKPaint): void;
    DrawRegion(region: SKRegion, paint: SKPaint): void;
    DrawRoundRect(rect: SKRoundRect, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, r: SKSize, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRect(x: number, y: number, w: number, h: number, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRectDifference(outer: SKRoundRect, inner: SKRoundRect, paint: SKPaint): void;
    DrawSurface(surface: SKSurface, p: SKPoint, paint?: SKPaint): void;
    DrawSurface(surface: SKSurface, x: number, y: number, paint?: SKPaint): void;
    DrawText(text: string, p: SKPoint, paint: SKPaint): void;
    DrawText(text: SKTextBlob, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawUrlAnnotation(rect: SKRect, value: string): SKData;
    DrawUrlAnnotation(rect: SKRect, value: SKData): void;
    DrawVertices(vertices: SKVertices, mode: SKBlendMode, paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], indices: number[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], mode: SKBlendMode, indices: number[], paint: SKPaint): void;
    Flush(): void;
    GetDeviceClipBounds(bounds: Out<SKRectI>): boolean;
    GetLocalClipBounds(bounds: Out<SKRect>): boolean;
    QuickReject(rect: SKRect): boolean;
    QuickReject(path: SKPath): boolean;
    ResetMatrix(): void;
    Restore(): void;
    RestoreToCount(count: number): void;
    RotateDegrees(degrees: number): void;
    RotateDegrees(degrees: number, px: number, py: number): void;
    RotateRadians(radians: number): void;
    RotateRadians(radians: number, px: number, py: number): void;
    Save(): number;
    SaveLayer(): number;
    SaveLayer(paint: SKPaint): number;
    SaveLayer(rec: Ref<SKCanvasSaveLayerRec>): number;
    SaveLayer(limit: SKRect, paint: SKPaint): number;
    Scale(s: number): void;
    Scale(size: SKPoint): void;
    Scale(sx: number, sy: number): void;
    Scale(sx: number, sy: number, px: number, py: number): void;
    SetMatrix(matrix: Ref<SKMatrix>): void;
    SetMatrix(matrix: SKMatrix): void;
    SetMatrix(matrix: Ref<SKMatrix44>): void;
    Skew(skew: SKPoint): void;
    Skew(sx: number, sy: number): void;
    Translate(point: SKPoint): void;
    Translate(dx: number, dy: number): void;
  }
  export interface SKNoDrawCanvas__statics {
    new(width: number, height: number): SKNoDrawCanvas;
  }

  export interface SKObject {
    Handle: number;
  }
  export interface SKOverdrawCanvas {
    readonly LocalClipBounds: SKRect;
    readonly DeviceClipBounds: SKRectI;
    readonly IsClipEmpty: boolean;
    readonly IsClipRect: boolean;
    readonly Surface: SKSurface;
    readonly Context: GRRecordingContext;
    readonly TotalMatrix: SKMatrix;
    readonly TotalMatrix44: SKMatrix44;
    readonly SaveCount: number;
    Handle: number;
    AddCanvas(canvas: SKCanvas): void;
    Clear(): void;
    Clear(color: SKColorF): void;
    Clear(color: SKColor): void;
    ClipPath(path: SKPath, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRect(rect: SKRect, operation?: SKClipOperation, antialias?: boolean): void;
    ClipRegion(region: SKRegion, operation?: SKClipOperation): void;
    ClipRoundRect(rect: SKRoundRect, operation?: SKClipOperation, antialias?: boolean): void;
    Concat(m: Ref<SKMatrix44>): void;
    Concat(m: Ref<SKMatrix>): void;
    Discard(): void;
    DrawAnnotation(rect: SKRect, key: string, value: SKData): void;
    DrawArc(oval: SKRect, startAngle: number, sweepAngle: number, useCenter: boolean, paint: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, cullRect: SKRect, paint?: SKPaint): void;
    DrawAtlas(atlas: SKImage, sprites: SKRect[], transforms: SKRotationScaleMatrix[], colors: SKColor[], mode: SKBlendMode, sampling: SKSamplingOptions, cullRect: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, p: SKPoint, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, dest: SKRect, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, x: number, y: number, paint?: SKPaint): void;
    DrawBitmap(bitmap: SKBitmap, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapLattice(bitmap: SKBitmap, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawBitmapNinePatch(bitmap: SKBitmap, center: SKRectI, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawCircle(c: SKPoint, radius: number, paint: SKPaint): void;
    DrawCircle(cx: number, cy: number, radius: number, paint: SKPaint): void;
    DrawColor(color: SKColorF, mode?: SKBlendMode): void;
    DrawColor(color: SKColor, mode?: SKBlendMode): void;
    DrawDrawable(drawable: SKDrawable, matrix: Ref<SKMatrix>): void;
    DrawDrawable(drawable: SKDrawable, p: SKPoint): void;
    DrawDrawable(drawable: SKDrawable, x: number, y: number): void;
    DrawImage(image: SKImage, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, paint?: SKPaint): void;
    DrawImage(image: SKImage, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, paint?: SKPaint): void;
    DrawImage(image: SKImage, p: SKPoint, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, x: number, y: number, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImage(image: SKImage, source: SKRect, dest: SKRect, sampling: SKSamplingOptions, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, lattice: SKLattice, dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageLattice(image: SKImage, xDivs: number[], yDivs: number[], dst: SKRect, filterMode: SKFilterMode, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, paint?: SKPaint): void;
    DrawImageNinePatch(image: SKImage, center: SKRectI, dst: SKRect, filterMode?: SKFilterMode, paint?: SKPaint): void;
    DrawLine(p0: SKPoint, p1: SKPoint, paint: SKPaint): void;
    DrawLine(x0: number, y0: number, x1: number, y1: number, paint: SKPaint): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: SKData): void;
    DrawLinkDestinationAnnotation(rect: SKRect, value: string): SKData;
    DrawNamedDestinationAnnotation(point: SKPoint, value: SKData): void;
    DrawNamedDestinationAnnotation(point: SKPoint, value: string): SKData;
    DrawOval(rect: SKRect, paint: SKPaint): void;
    DrawOval(c: SKPoint, r: SKSize, paint: SKPaint): void;
    DrawOval(cx: number, cy: number, rx: number, ry: number, paint: SKPaint): void;
    DrawPaint(paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], paint: SKPaint): void;
    DrawPatch(cubics: SKPoint[], colors: SKColor[], texCoords: SKPoint[], mode: SKBlendMode, paint: SKPaint): void;
    DrawPath(path: SKPath, paint: SKPaint): void;
    DrawPicture(picture: SKPicture, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, matrix: Ref<SKMatrix>, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, p: SKPoint, paint?: SKPaint): void;
    DrawPicture(picture: SKPicture, x: number, y: number, paint?: SKPaint): void;
    DrawPoint(p: SKPoint, color: SKColor): void;
    DrawPoint(p: SKPoint, paint: SKPaint): void;
    DrawPoint(x: number, y: number, color: SKColor): void;
    DrawPoint(x: number, y: number, paint: SKPaint): void;
    DrawPoints(mode: SKPointMode, points: SKPoint[], paint: SKPaint): void;
    DrawRect(rect: SKRect, paint: SKPaint): void;
    DrawRect(x: number, y: number, w: number, h: number, paint: SKPaint): void;
    DrawRegion(region: SKRegion, paint: SKPaint): void;
    DrawRoundRect(rect: SKRoundRect, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, r: SKSize, paint: SKPaint): void;
    DrawRoundRect(rect: SKRect, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRect(x: number, y: number, w: number, h: number, rx: number, ry: number, paint: SKPaint): void;
    DrawRoundRectDifference(outer: SKRoundRect, inner: SKRoundRect, paint: SKPaint): void;
    DrawSurface(surface: SKSurface, p: SKPoint, paint?: SKPaint): void;
    DrawSurface(surface: SKSurface, x: number, y: number, paint?: SKPaint): void;
    DrawText(text: string, p: SKPoint, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, paint: SKPaint): void;
    DrawText(text: SKTextBlob, x: number, y: number, paint: SKPaint): void;
    DrawText(text: string, p: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, font: SKFont, paint: SKPaint): void;
    DrawText(text: string, x: number, y: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, hOffset: number, vOffset: number, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawTextOnPath(text: string, path: SKPath, offset: SKPoint, warpGlyphs: boolean, textAlign: SKTextAlign, font: SKFont, paint: SKPaint): void;
    DrawUrlAnnotation(rect: SKRect, value: string): SKData;
    DrawUrlAnnotation(rect: SKRect, value: SKData): void;
    DrawVertices(vertices: SKVertices, mode: SKBlendMode, paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], indices: number[], paint: SKPaint): void;
    DrawVertices(vmode: SKVertexMode, vertices: SKPoint[], texs: SKPoint[], colors: SKColor[], mode: SKBlendMode, indices: number[], paint: SKPaint): void;
    Flush(): void;
    GetDeviceClipBounds(bounds: Out<SKRectI>): boolean;
    GetLocalClipBounds(bounds: Out<SKRect>): boolean;
    QuickReject(path: SKPath): boolean;
    QuickReject(rect: SKRect): boolean;
    RemoveAll(): void;
    RemoveCanvas(canvas: SKCanvas): void;
    ResetMatrix(): void;
    Restore(): void;
    RestoreToCount(count: number): void;
    RotateDegrees(degrees: number): void;
    RotateDegrees(degrees: number, px: number, py: number): void;
    RotateRadians(radians: number): void;
    RotateRadians(radians: number, px: number, py: number): void;
    Save(): number;
    SaveLayer(): number;
    SaveLayer(paint: SKPaint): number;
    SaveLayer(rec: Ref<SKCanvasSaveLayerRec>): number;
    SaveLayer(limit: SKRect, paint: SKPaint): number;
    Scale(s: number): void;
    Scale(size: SKPoint): void;
    Scale(sx: number, sy: number): void;
    Scale(sx: number, sy: number, px: number, py: number): void;
    SetMatrix(matrix: SKMatrix): void;
    SetMatrix(matrix: Ref<SKMatrix44>): void;
    SetMatrix(matrix: Ref<SKMatrix>): void;
    Skew(skew: SKPoint): void;
    Skew(sx: number, sy: number): void;
    Translate(point: SKPoint): void;
    Translate(dx: number, dy: number): void;
  }
  export interface SKOverdrawCanvas__statics {
    new(canvas: SKCanvas): SKOverdrawCanvas;
  }

  export interface SKPMColor {
    readonly Alpha: number;
    readonly Red: number;
    readonly Green: number;
    readonly Blue: number;
    Equals(obj: SKPMColor): boolean;
    Equals(other: any): boolean;
    GetHashCode(): number;
    ToString(): string;
  }
  export interface SKPMColor__statics {
    new(value: number): SKPMColor;
    PreMultiply(color: SKColor): SKPMColor;
    PreMultiply(colors: SKColor[]): SKPMColor[];
    UnPreMultiply(pmcolor: SKPMColor): SKColor;
    UnPreMultiply(pmcolors: SKPMColor[]): SKColor[];
  }

  export interface SKPaint {
    IsAntialias: boolean;
    IsDither: boolean;
    IsLinearText: boolean;
    SubpixelText: boolean;
    LcdRenderText: boolean;
    IsEmbeddedBitmapText: boolean;
    IsAutohinted: boolean;
    HintingLevel: SKPaintHinting;
    FakeBoldText: boolean;
    IsStroke: boolean;
    Style: SKPaintStyle;
    Color: SKColor;
    ColorF: SKColorF;
    StrokeWidth: number;
    StrokeMiter: number;
    StrokeCap: SKStrokeCap;
    StrokeJoin: SKStrokeJoin;
    Shader: SKShader;
    MaskFilter: SKMaskFilter;
    ColorFilter: SKColorFilter;
    ImageFilter: SKImageFilter;
    BlendMode: SKBlendMode;
    Blender: SKBlender;
    FilterQuality: SKFilterQuality;
    Typeface: SKTypeface;
    TextSize: number;
    TextAlign: SKTextAlign;
    TextEncoding: SKTextEncoding;
    TextScaleX: number;
    TextSkewX: number;
    PathEffect: SKPathEffect;
    readonly FontSpacing: number;
    readonly FontMetrics: SKFontMetrics;
    Handle: number;
    BreakText(text: number[], maxWidth: number): number;
    BreakText(text: string, maxWidth: number): number;
    BreakText(buffer: number, length: number, maxWidth: number): number;
    BreakText(text: string, maxWidth: number, measuredWidth: Out<number>): number;
    BreakText(buffer: number, length: number, maxWidth: number): number;
    BreakText(text: number[], maxWidth: number, measuredWidth: Out<number>): number;
    BreakText(buffer: number, length: number, maxWidth: number, measuredWidth: Out<number>): number;
    BreakText(buffer: number, length: number, maxWidth: number, measuredWidth: Out<number>): number;
    BreakText(text: string, maxWidth: number, measuredWidth: Out<number>, measuredText: Out<string>): number;
    Clone(): SKPaint;
    ContainsGlyphs(text: string): boolean;
    ContainsGlyphs(text: number[]): boolean;
    ContainsGlyphs(text: number, length: number): boolean;
    ContainsGlyphs(text: number, length: number): boolean;
    CountGlyphs(text: string): number;
    CountGlyphs(text: number[]): number;
    CountGlyphs(text: number, length: number): number;
    CountGlyphs(text: number, length: number): number;
    GetFillPath(src: SKPath): SKPath;
    GetFillPath(src: SKPath, dst: SKPath): boolean;
    GetFillPath(src: SKPath, cullRect: SKRect): SKPath;
    GetFillPath(src: SKPath, matrix: SKMatrix): SKPath;
    GetFillPath(src: SKPath, resScale: number): SKPath;
    GetFillPath(src: SKPath, dst: SKPath, cullRect: SKRect): boolean;
    GetFillPath(src: SKPath, dst: SKPath, resScale: number): boolean;
    GetFillPath(src: SKPath, cullRect: SKRect, matrix: SKMatrix): SKPath;
    GetFillPath(src: SKPath, cullRect: SKRect, resScale: number): SKPath;
    GetFillPath(src: SKPath, dst: SKPath, matrix: SKMatrix): boolean;
    GetFillPath(src: SKPath, dst: SKPath, cullRect: SKRect, matrix: SKMatrix): boolean;
    GetFillPath(src: SKPath, dst: SKPath, cullRect: SKRect, resScale: number): boolean;
    GetFontMetrics(metrics: Out<SKFontMetrics>): number;
    GetGlyphOffsets(text: string, origin?: number): number[];
    GetGlyphOffsets(text: number, length: number, origin?: number): number[];
    GetGlyphPositions(text: string, origin?: SKPoint): SKPoint[];
    GetGlyphPositions(text: number, length: number, origin?: SKPoint): SKPoint[];
    GetGlyphWidths(text: string): number[];
    GetGlyphWidths(text: number[]): number[];
    GetGlyphWidths(text: number[], bounds: Out<SKRect[]>): number[];
    GetGlyphWidths(text: string, bounds: Out<SKRect[]>): number[];
    GetGlyphWidths(text: number, length: number): number[];
    GetGlyphWidths(text: number, length: number): number[];
    GetGlyphWidths(text: number, length: number, bounds: Out<SKRect[]>): number[];
    GetGlyphWidths(text: number, length: number, bounds: Out<SKRect[]>): number[];
    GetGlyphs(text: number[]): number[];
    GetGlyphs(text: string): number[];
    GetGlyphs(text: number, length: number): number[];
    GetGlyphs(text: number, length: number): number[];
    GetHorizontalTextIntercepts(text: string, xpositions: number[], y: number, upperBounds: number, lowerBounds: number): number[];
    GetHorizontalTextIntercepts(text: number[], xpositions: number[], y: number, upperBounds: number, lowerBounds: number): number[];
    GetHorizontalTextIntercepts(text: number, length: number, xpositions: number[], y: number, upperBounds: number, lowerBounds: number): number[];
    GetHorizontalTextIntercepts(text: number, length: number, xpositions: number[], y: number, upperBounds: number, lowerBounds: number): number[];
    GetPositionedTextIntercepts(text: number[], positions: SKPoint[], upperBounds: number, lowerBounds: number): number[];
    GetPositionedTextIntercepts(text: string, positions: SKPoint[], upperBounds: number, lowerBounds: number): number[];
    GetPositionedTextIntercepts(text: number, length: number, positions: SKPoint[], upperBounds: number, lowerBounds: number): number[];
    GetPositionedTextIntercepts(text: number, length: number, positions: SKPoint[], upperBounds: number, lowerBounds: number): number[];
    GetTextIntercepts(text: SKTextBlob, upperBounds: number, lowerBounds: number): number[];
    GetTextIntercepts(text: number[], x: number, y: number, upperBounds: number, lowerBounds: number): number[];
    GetTextIntercepts(text: string, x: number, y: number, upperBounds: number, lowerBounds: number): number[];
    GetTextIntercepts(text: number, length: number, x: number, y: number, upperBounds: number, lowerBounds: number): number[];
    GetTextIntercepts(text: number, length: number, x: number, y: number, upperBounds: number, lowerBounds: number): number[];
    GetTextPath(text: string, points: SKPoint[]): SKPath;
    GetTextPath(text: number[], points: SKPoint[]): SKPath;
    GetTextPath(buffer: number, length: number, points: SKPoint[]): SKPath;
    GetTextPath(buffer: number, length: number, points: SKPoint[]): SKPath;
    GetTextPath(text: string, x: number, y: number): SKPath;
    GetTextPath(text: number[], x: number, y: number): SKPath;
    GetTextPath(buffer: number, length: number, x: number, y: number): SKPath;
    GetTextPath(buffer: number, length: number, x: number, y: number): SKPath;
    MeasureText(text: number[]): number;
    MeasureText(text: string): number;
    MeasureText(text: number[], bounds: Ref<SKRect>): number;
    MeasureText(text: string, bounds: Ref<SKRect>): number;
    MeasureText(buffer: number, length: number): number;
    MeasureText(buffer: number, length: number): number;
    MeasureText(buffer: number, length: number, bounds: Ref<SKRect>): number;
    MeasureText(buffer: number, length: number, bounds: Ref<SKRect>): number;
    Reset(): void;
    SetColor(color: SKColorF, colorspace: SKColorSpace): void;
    ToFont(): SKFont;
  }
  export interface SKPaint__statics {
    new(): SKPaint;
    new(font: SKFont): SKPaint;
  }

  export enum SKPaintHinting {
    NoHinting = 0,
    Slight = 1,
    Normal = 2,
    Full = 3,
  }

  export enum SKPaintStyle {
    Fill = 0,
    Stroke = 1,
    StrokeAndFill = 2,
  }

  export interface SKPath {
    FillType: SKPathFillType;
    readonly Convexity: SKPathConvexity;
    readonly IsConvex: boolean;
    readonly IsConcave: boolean;
    readonly IsEmpty: boolean;
    readonly IsOval: boolean;
    readonly IsRoundRect: boolean;
    readonly IsLine: boolean;
    readonly IsRect: boolean;
    readonly SegmentMasks: SKPathSegmentMask;
    readonly VerbCount: number;
    readonly PointCount: number;
    get_Item(index: number): SKPoint;
    readonly Points: SKPoint[];
    readonly LastPoint: SKPoint;
    readonly Bounds: SKRect;
    readonly TightBounds: SKRect;
    Handle: number;
    AddArc(oval: SKRect, startAngle: number, sweepAngle: number): void;
    AddCircle(x: number, y: number, radius: number, dir?: SKPathDirection): void;
    AddOval(rect: SKRect, direction?: SKPathDirection): void;
    AddPath(other: SKPath, mode?: SKPathAddMode): void;
    AddPath(other: SKPath, matrix: Ref<SKMatrix>, mode?: SKPathAddMode): void;
    AddPath(other: SKPath, dx: number, dy: number, mode?: SKPathAddMode): void;
    AddPathReverse(other: SKPath): void;
    AddPoly(points: SKPoint[], close?: boolean): void;
    AddRect(rect: SKRect, direction?: SKPathDirection): void;
    AddRect(rect: SKRect, direction: SKPathDirection, startIndex: number): void;
    AddRoundRect(rect: SKRoundRect, direction?: SKPathDirection): void;
    AddRoundRect(rect: SKRoundRect, direction: SKPathDirection, startIndex: number): void;
    AddRoundRect(rect: SKRect, rx: number, ry: number, dir?: SKPathDirection): void;
    ArcTo(point1: SKPoint, point2: SKPoint, radius: number): void;
    ArcTo(oval: SKRect, startAngle: number, sweepAngle: number, forceMoveTo: boolean): void;
    ArcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    ArcTo(r: SKPoint, xAxisRotate: number, largeArc: SKPathArcSize, sweep: SKPathDirection, xy: SKPoint): void;
    ArcTo(rx: number, ry: number, xAxisRotate: number, largeArc: SKPathArcSize, sweep: SKPathDirection, x: number, y: number): void;
    Close(): void;
    ComputeTightBounds(): SKRect;
    ConicTo(point0: SKPoint, point1: SKPoint, w: number): void;
    ConicTo(x0: number, y0: number, x1: number, y1: number, w: number): void;
    Contains(x: number, y: number): boolean;
    CubicTo(point0: SKPoint, point1: SKPoint, point2: SKPoint): void;
    CubicTo(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): void;
    GetBounds(rect: Out<SKRect>): boolean;
    GetLine(): SKPoint[];
    GetOvalBounds(): SKRect;
    GetPoint(index: number): SKPoint;
    GetPoints(max: number): SKPoint[];
    GetPoints(points: SKPoint[], max: number): number;
    GetRect(): SKRect;
    GetRect(isClosed: Out<boolean>, direction: Out<SKPathDirection>): SKRect;
    GetRoundRect(): SKRoundRect;
    GetTightBounds(result: Out<SKRect>): boolean;
    LineTo(point: SKPoint): void;
    LineTo(x: number, y: number): void;
    MoveTo(point: SKPoint): void;
    MoveTo(x: number, y: number): void;
    Offset(offset: SKPoint): void;
    Offset(dx: number, dy: number): void;
    Op(other: SKPath, op: SKPathOp): SKPath;
    Op(other: SKPath, op: SKPathOp, result: SKPath): boolean;
    QuadTo(point0: SKPoint, point1: SKPoint): void;
    QuadTo(x0: number, y0: number, x1: number, y1: number): void;
    RArcTo(r: SKPoint, xAxisRotate: number, largeArc: SKPathArcSize, sweep: SKPathDirection, xy: SKPoint): void;
    RArcTo(rx: number, ry: number, xAxisRotate: number, largeArc: SKPathArcSize, sweep: SKPathDirection, x: number, y: number): void;
    RConicTo(point0: SKPoint, point1: SKPoint, w: number): void;
    RConicTo(dx0: number, dy0: number, dx1: number, dy1: number, w: number): void;
    RCubicTo(point0: SKPoint, point1: SKPoint, point2: SKPoint): void;
    RCubicTo(dx0: number, dy0: number, dx1: number, dy1: number, dx2: number, dy2: number): void;
    RLineTo(point: SKPoint): void;
    RLineTo(dx: number, dy: number): void;
    RMoveTo(point: SKPoint): void;
    RMoveTo(dx: number, dy: number): void;
    RQuadTo(point0: SKPoint, point1: SKPoint): void;
    RQuadTo(dx0: number, dy0: number, dx1: number, dy1: number): void;
    Reset(): void;
    Rewind(): void;
    Simplify(): SKPath;
    Simplify(result: SKPath): boolean;
    ToSvgPathData(): string;
    ToWinding(): SKPath;
    ToWinding(result: SKPath): boolean;
    Transform(matrix: SKMatrix): void;
    Transform(matrix: Ref<SKMatrix>): void;
    Transform(matrix: SKMatrix, destination: SKPath): void;
    Transform(matrix: Ref<SKMatrix>, destination: SKPath): void;
  }
  export interface SKPath__statics {
    new(): SKPath;
    new(path: SKPath): SKPath;
    ParseSvgPathData(svgPath: string): SKPath;
    ConvertConicToQuads(p0: SKPoint, p1: SKPoint, p2: SKPoint, w: number, pow2: number): SKPoint[];
    ConvertConicToQuads(p0: SKPoint, p1: SKPoint, p2: SKPoint, w: number, pts: Out<SKPoint[]>, pow2: number): number;
    ConvertConicToQuads(p0: SKPoint, p1: SKPoint, p2: SKPoint, w: number, pts: SKPoint[], pow2: number): number;
  }

  export namespace SKPath {
    export interface Iterator {
      Handle: number;
      ConicWeight(): number;
      IsCloseContour(): boolean;
      IsCloseLine(): boolean;
      Next(points: SKPoint[]): SKPathVerb;
    }
    export interface OpBuilder {
      Handle: number;
      Add(path: SKPath, op: SKPathOp): void;
      Resolve(result: SKPath): boolean;
    }
    export interface OpBuilder__statics {
      new(): OpBuilder;
    }

    export interface RawIterator {
      Handle: number;
      ConicWeight(): number;
      Next(points: SKPoint[]): SKPathVerb;
      Peek(): SKPathVerb;
    }
  }
  export enum SKPath1DPathEffectStyle {
    Translate = 0,
    Rotate = 1,
    Morph = 2,
  }

  export enum SKPathAddMode {
    Append = 0,
    Extend = 1,
  }

  export enum SKPathArcSize {
    Small = 0,
    Large = 1,
  }

  export enum SKPathConvexity {
    Unknown = 0,
    Convex = 1,
    Concave = 2,
  }

  export enum SKPathDirection {
    Clockwise = 0,
    CounterClockwise = 1,
  }

  export interface SKPathEffect {
    Handle: number;
  }
  export interface SKPathEffect__statics {
    CreateCompose(outer: SKPathEffect, inner: SKPathEffect): SKPathEffect;
    CreateSum(first: SKPathEffect, second: SKPathEffect): SKPathEffect;
    CreateDiscrete(segLength: number, deviation: number, seedAssist?: number): SKPathEffect;
    CreateCorner(radius: number): SKPathEffect;
    Create1DPath(path: SKPath, advance: number, phase: number, style: SKPath1DPathEffectStyle): SKPathEffect;
    Create2DLine(width: number, matrix: SKMatrix): SKPathEffect;
    Create2DPath(matrix: SKMatrix, path: SKPath): SKPathEffect;
    CreateDash(intervals: number[], phase: number): SKPathEffect;
    CreateTrim(start: number, stop: number): SKPathEffect;
    CreateTrim(start: number, stop: number, mode: SKTrimPathEffectMode): SKPathEffect;
  }

  export enum SKPathFillType {
    Winding = 0,
    EvenOdd = 1,
    InverseWinding = 2,
    InverseEvenOdd = 3,
  }

  export interface SKPathMeasure {
    readonly Length: number;
    readonly IsClosed: boolean;
    Handle: number;
    GetMatrix(distance: number, flags: SKPathMeasureMatrixFlags): SKMatrix;
    GetMatrix(distance: number, matrix: Out<SKMatrix>, flags: SKPathMeasureMatrixFlags): boolean;
    GetPosition(distance: number): SKPoint;
    GetPosition(distance: number, position: Out<SKPoint>): boolean;
    GetPositionAndTangent(distance: number, position: Out<SKPoint>, tangent: Out<SKPoint>): boolean;
    GetSegment(start: number, stop: number, startWithMoveTo: boolean): SKPath;
    GetSegment(start: number, stop: number, dst: SKPath, startWithMoveTo: boolean): boolean;
    GetTangent(distance: number): SKPoint;
    GetTangent(distance: number, tangent: Out<SKPoint>): boolean;
    NextContour(): boolean;
    SetPath(path: SKPath): void;
    SetPath(path: SKPath, forceClosed: boolean): void;
  }
  export interface SKPathMeasure__statics {
    new(): SKPathMeasure;
    new(path: SKPath, forceClosed?: boolean, resScale?: number): SKPathMeasure;
  }

  export enum SKPathMeasureMatrixFlags {
    GetPosition = 1,
    GetTangent = 2,
    GetPositionAndTangent = 3,
  }

  export enum SKPathOp {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    Xor = 3,
    ReverseDifference = 4,
  }

  export enum SKPathSegmentMask {
    Line = 1,
    Quad = 2,
    Conic = 4,
    Cubic = 8,
  }

  export enum SKPathVerb {
    Move = 0,
    Line = 1,
    Quad = 2,
    Conic = 3,
    Cubic = 4,
    Close = 5,
    Done = 6,
  }

  export interface SKPicture {
    readonly UniqueId: number;
    readonly CullRect: SKRect;
    readonly ApproximateBytesUsed: number;
    readonly ApproximateOperationCount: number;
    Handle: number;
    GetApproximateOperationCount(includeNested: boolean): number;
    Playback(canvas: SKCanvas): void;
    Serialize(): SKData;
    Serialize(stream: SKWStream): void;
    ToShader(): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, tile: SKRect): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode, tile: SKRect): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, localMatrix: SKMatrix, tile: SKRect): SKShader;
    ToShader(tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode, localMatrix: SKMatrix, tile: SKRect): SKShader;
  }
  export interface SKPicture__statics {
    Deserialize(data: number, length: number): SKPicture;
    Deserialize(data: SKData): SKPicture;
    Deserialize(stream: SKStream): SKPicture;
  }

  export interface SKPictureRecorder {
    readonly RecordingCanvas: SKCanvas;
    Handle: number;
    BeginRecording(cullRect: SKRect): SKCanvas;
    BeginRecording(cullRect: SKRect, useRTree: boolean): SKCanvas;
    EndRecording(): SKPicture;
    EndRecordingAsDrawable(): SKDrawable;
  }
  export interface SKPictureRecorder__statics {
    new(): SKPictureRecorder;
  }

  export enum SKPixelGeometry {
    Unknown = 0,
    RgbHorizontal = 1,
    BgrHorizontal = 2,
    RgbVertical = 3,
    BgrVertical = 4,
  }

  export interface SKPixmap {
    readonly Info: SKImageInfo;
    readonly Width: number;
    readonly Height: number;
    readonly Size: SKSizeI;
    readonly Rect: SKRectI;
    readonly ColorType: SKColorType;
    readonly AlphaType: SKAlphaType;
    readonly ColorSpace: SKColorSpace;
    readonly BytesPerPixel: number;
    readonly BitShiftPerPixel: number;
    readonly RowBytes: number;
    readonly BytesSize: number;
    readonly BytesSize64: number;
    Handle: number;
    ComputeIsOpaque(): boolean;
    Encode(options: SKPngEncoderOptions): SKData;
    Encode(options: SKJpegEncoderOptions): SKData;
    Encode(options: SKWebpEncoderOptions): SKData;
    Encode(dst: SKWStream, options: SKPngEncoderOptions): boolean;
    Encode(dst: SKWStream, options: SKJpegEncoderOptions): boolean;
    Encode(dst: SKWStream, options: SKWebpEncoderOptions): boolean;
    Encode(encoder: SKEncodedImageFormat, quality: number): SKData;
    Encode(dst: SKWStream, encoder: SKEncodedImageFormat, quality: number): boolean;
    Erase(color: SKColorF): boolean;
    Erase(color: SKColor): boolean;
    Erase(color: SKColorF, subset: SKRectI): boolean;
    Erase(color: SKColor, subset: SKRectI): boolean;
    ExtractSubset(subset: SKRectI): SKPixmap;
    ExtractSubset(result: SKPixmap, subset: SKRectI): boolean;
    GetPixelAlpha(x: number, y: number): number;
    GetPixelColor(x: number, y: number): SKColor;
    GetPixelColorF(x: number, y: number): SKColorF;
    GetPixels(): number;
    GetPixels(x: number, y: number): number;
    ReadPixels(pixmap: SKPixmap): boolean;
    ReadPixels(pixmap: SKPixmap, srcX: number, srcY: number): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number, srcX: number, srcY: number): boolean;
    Reset(): void;
    Reset(info: SKImageInfo, addr: number, rowBytes: number): void;
    ScalePixels(destination: SKPixmap): boolean;
    ScalePixels(destination: SKPixmap, sampling: SKSamplingOptions): boolean;
    ScalePixels(destination: SKPixmap, quality: SKFilterQuality): boolean;
    WithAlphaType(newAlphaType: SKAlphaType): SKPixmap;
    WithColorSpace(newColorSpace: SKColorSpace): SKPixmap;
    WithColorType(newColorType: SKColorType): SKPixmap;
  }
  export interface SKPixmap__statics {
    new(): SKPixmap;
    new(info: SKImageInfo, addr: number): SKPixmap;
    new(info: SKImageInfo, addr: number, rowBytes: number): SKPixmap;
  }

  export enum SKPngEncoderFilterFlags {
    NoFilters = 0,
    None = 8,
    Sub = 16,
    Up = 32,
    Avg = 64,
    Paeth = 128,
    AllFilters = 248,
  }

  export interface SKPngEncoderOptions {
    readonly FilterFlags: SKPngEncoderFilterFlags;
    readonly ZLibLevel: number;
    Equals(obj: SKPngEncoderOptions): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKPngEncoderOptions__statics {
    new(filterFlags: SKPngEncoderFilterFlags, zLibLevel: number): SKPngEncoderOptions;
    Default: SKPngEncoderOptions;
  }

  export interface SKPoint {
    readonly IsEmpty: boolean;
    readonly Length: number;
    readonly LengthSquared: number;
    X: number;
    Y: number;
    Equals(obj: SKPoint): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Offset(p: SKPoint): void;
    Offset(dx: number, dy: number): void;
    ToString(): string;
  }
  export interface SKPoint__statics {
    new(x: number, y: number): SKPoint;
    Empty: SKPoint;
    Normalize(point: SKPoint): SKPoint;
    Distance(point: SKPoint, other: SKPoint): number;
    DistanceSquared(point: SKPoint, other: SKPoint): number;
    Reflect(point: SKPoint, normal: SKPoint): SKPoint;
    Add(pt: SKPoint, sz: SKSizeI): SKPoint;
    Add(pt: SKPoint, sz: SKSize): SKPoint;
    Add(pt: SKPoint, sz: SKPointI): SKPoint;
    Add(pt: SKPoint, sz: SKPoint): SKPoint;
    Subtract(pt: SKPoint, sz: SKSizeI): SKPoint;
    Subtract(pt: SKPoint, sz: SKSize): SKPoint;
    Subtract(pt: SKPoint, sz: SKPointI): SKPoint;
    Subtract(pt: SKPoint, sz: SKPoint): SKPoint;
  }

  export interface SKPoint3 {
    readonly IsEmpty: boolean;
    X: number;
    Y: number;
    Z: number;
    Equals(obj: SKPoint3): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToString(): string;
  }
  export interface SKPoint3__statics {
    new(x: number, y: number, z: number): SKPoint3;
    Empty: SKPoint3;
    Add(pt: SKPoint3, sz: SKPoint3): SKPoint3;
    Subtract(pt: SKPoint3, sz: SKPoint3): SKPoint3;
  }

  export interface SKPointI {
    readonly IsEmpty: boolean;
    readonly Length: number;
    readonly LengthSquared: number;
    X: number;
    Y: number;
    Equals(obj: SKPointI): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    Offset(p: SKPointI): void;
    Offset(dx: number, dy: number): void;
    ToString(): string;
  }
  export interface SKPointI__statics {
    new(sz: SKSizeI): SKPointI;
    new(x: number, y: number): SKPointI;
    Empty: SKPointI;
    Normalize(point: SKPointI): SKPointI;
    Distance(point: SKPointI, other: SKPointI): number;
    DistanceSquared(point: SKPointI, other: SKPointI): number;
    Reflect(point: SKPointI, normal: SKPointI): SKPointI;
    Ceiling(value: SKPoint): SKPointI;
    Round(value: SKPoint): SKPointI;
    Truncate(value: SKPoint): SKPointI;
    Add(pt: SKPointI, sz: SKSizeI): SKPointI;
    Add(pt: SKPointI, sz: SKPointI): SKPointI;
    Subtract(pt: SKPointI, sz: SKSizeI): SKPointI;
    Subtract(pt: SKPointI, sz: SKPointI): SKPointI;
  }

  export enum SKPointMode {
    Points = 0,
    Lines = 1,
    Polygon = 2,
  }

  export interface SKPositionedRunBuffer {
    readonly Size: number;
  }
  export interface SKPositionedTextRunBuffer {
    readonly TextSize: number;
    readonly Size: number;
  }
  export interface SKRawRunBuffer<T> {
  }
  export interface SKRect {
    readonly MidX: number;
    readonly MidY: number;
    readonly Width: number;
    readonly Height: number;
    readonly IsEmpty: boolean;
    Size: SKSize;
    Location: SKPoint;
    readonly Standardized: SKRect;
    Left: number;
    Top: number;
    Right: number;
    Bottom: number;
    AspectFill(size: SKSize): SKRect;
    AspectFit(size: SKSize): SKRect;
    Contains(pt: SKPoint): boolean;
    Contains(rect: SKRect): boolean;
    Contains(x: number, y: number): boolean;
    Equals(obj: any): boolean;
    Equals(obj: SKRect): boolean;
    GetHashCode(): number;
    Inflate(size: SKSize): void;
    Inflate(x: number, y: number): void;
    Intersect(rect: SKRect): void;
    IntersectsWith(rect: SKRect): boolean;
    IntersectsWithInclusive(rect: SKRect): boolean;
    Offset(pos: SKPoint): void;
    Offset(x: number, y: number): void;
    ToString(): string;
    Union(rect: SKRect): void;
  }
  export interface SKRect__statics {
    new(left: number, top: number, right: number, bottom: number): SKRect;
    Empty: SKRect;
    Inflate(rect: SKRect, x: number, y: number): SKRect;
    Intersect(a: SKRect, b: SKRect): SKRect;
    Union(a: SKRect, b: SKRect): SKRect;
    Create(location: SKPoint, size: SKSize): SKRect;
    Create(size: SKSize): SKRect;
    Create(width: number, height: number): SKRect;
    Create(x: number, y: number, width: number, height: number): SKRect;
  }

  export interface SKRectI {
    readonly MidX: number;
    readonly MidY: number;
    readonly Width: number;
    readonly Height: number;
    readonly IsEmpty: boolean;
    Size: SKSizeI;
    Location: SKPointI;
    readonly Standardized: SKRectI;
    Left: number;
    Top: number;
    Right: number;
    Bottom: number;
    AspectFill(size: SKSizeI): SKRectI;
    AspectFit(size: SKSizeI): SKRectI;
    Contains(pt: SKPointI): boolean;
    Contains(rect: SKRectI): boolean;
    Contains(x: number, y: number): boolean;
    Equals(obj: any): boolean;
    Equals(obj: SKRectI): boolean;
    GetHashCode(): number;
    Inflate(size: SKSizeI): void;
    Inflate(width: number, height: number): void;
    Intersect(rect: SKRectI): void;
    IntersectsWith(rect: SKRectI): boolean;
    IntersectsWithInclusive(rect: SKRectI): boolean;
    Offset(pos: SKPointI): void;
    Offset(x: number, y: number): void;
    ToString(): string;
    Union(rect: SKRectI): void;
  }
  export interface SKRectI__statics {
    new(left: number, top: number, right: number, bottom: number): SKRectI;
    Empty: SKRectI;
    Ceiling(value: SKRect): SKRectI;
    Ceiling(value: SKRect, outwards: boolean): SKRectI;
    Inflate(rect: SKRectI, x: number, y: number): SKRectI;
    Intersect(a: SKRectI, b: SKRectI): SKRectI;
    Round(value: SKRect): SKRectI;
    Floor(value: SKRect): SKRectI;
    Floor(value: SKRect, inwards: boolean): SKRectI;
    Truncate(value: SKRect): SKRectI;
    Union(a: SKRectI, b: SKRectI): SKRectI;
    Create(size: SKSizeI): SKRectI;
    Create(location: SKPointI, size: SKSizeI): SKRectI;
    Create(width: number, height: number): SKRectI;
    Create(x: number, y: number, width: number, height: number): SKRectI;
  }

  export interface SKRegion {
    readonly IsEmpty: boolean;
    readonly IsRect: boolean;
    readonly IsComplex: boolean;
    readonly Bounds: SKRectI;
    Handle: number;
    Contains(path: SKPath): boolean;
    Contains(src: SKRegion): boolean;
    Contains(xy: SKPointI): boolean;
    Contains(rect: SKRectI): boolean;
    Contains(x: number, y: number): boolean;
    GetBoundaryPath(): SKPath;
    Intersects(rect: SKRectI): boolean;
    Intersects(path: SKPath): boolean;
    Intersects(region: SKRegion): boolean;
    Op(region: SKRegion, op: SKRegionOperation): boolean;
    Op(rect: SKRectI, op: SKRegionOperation): boolean;
    Op(path: SKPath, op: SKRegionOperation): boolean;
    Op(left: number, top: number, right: number, bottom: number, op: SKRegionOperation): boolean;
    QuickContains(rect: SKRectI): boolean;
    QuickReject(path: SKPath): boolean;
    QuickReject(rect: SKRectI): boolean;
    QuickReject(region: SKRegion): boolean;
    SetEmpty(): void;
    SetPath(path: SKPath): boolean;
    SetPath(path: SKPath, clip: SKRegion): boolean;
    SetRect(rect: SKRectI): boolean;
    SetRegion(region: SKRegion): boolean;
    Translate(x: number, y: number): void;
  }
  export interface SKRegion__statics {
    new(): SKRegion;
    new(region: SKRegion): SKRegion;
    new(rect: SKRectI): SKRegion;
    new(path: SKPath): SKRegion;
  }

  export namespace SKRegion {
    export interface ClipIterator {
      Handle: number;
      Next(rect: Out<SKRectI>): boolean;
    }
    export interface RectIterator {
      Handle: number;
      Next(rect: Out<SKRectI>): boolean;
    }
    export interface SpanIterator {
      Handle: number;
      Next(left: Out<number>, right: Out<number>): boolean;
    }
  }
  export enum SKRegionOperation {
    Difference = 0,
    Intersect = 1,
    Union = 2,
    XOR = 3,
    ReverseDifference = 4,
    Replace = 5,
  }

  export interface SKRotationScaleMatrix {
    SCos: number;
    SSin: number;
    TX: number;
    TY: number;
    Equals(obj: SKRotationScaleMatrix): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToMatrix(): SKMatrix;
  }
  export interface SKRotationScaleMatrix__statics {
    new(scos: number, ssin: number, tx: number, ty: number): SKRotationScaleMatrix;
    Empty: SKRotationScaleMatrix;
    Identity: SKRotationScaleMatrix;
    CreateDegrees(scale: number, degrees: number, tx: number, ty: number, anchorX: number, anchorY: number): SKRotationScaleMatrix;
    Create(scale: number, radians: number, tx: number, ty: number, anchorX: number, anchorY: number): SKRotationScaleMatrix;
    CreateIdentity(): SKRotationScaleMatrix;
    CreateTranslation(x: number, y: number): SKRotationScaleMatrix;
    CreateScale(s: number): SKRotationScaleMatrix;
    CreateRotation(radians: number, anchorX: number, anchorY: number): SKRotationScaleMatrix;
    CreateRotationDegrees(degrees: number, anchorX: number, anchorY: number): SKRotationScaleMatrix;
  }

  export interface SKRotationScaleRunBuffer {
    readonly Size: number;
  }
  export interface SKRotationScaleTextRunBuffer {
    readonly TextSize: number;
    readonly Size: number;
  }
  export interface SKRoundRect {
    readonly Rect: SKRect;
    readonly Radii: SKPoint[];
    readonly Type: SKRoundRectType;
    readonly Width: number;
    readonly Height: number;
    readonly IsValid: boolean;
    readonly AllCornersCircular: boolean;
    Handle: number;
    CheckAllCornersCircular(tolerance: number): boolean;
    Contains(rect: SKRect): boolean;
    Deflate(size: SKSize): void;
    Deflate(dx: number, dy: number): void;
    GetRadii(corner: SKRoundRectCorner): SKPoint;
    Inflate(size: SKSize): void;
    Inflate(dx: number, dy: number): void;
    Offset(pos: SKPoint): void;
    Offset(dx: number, dy: number): void;
    SetEmpty(): void;
    SetNinePatch(rect: SKRect, leftRadius: number, topRadius: number, rightRadius: number, bottomRadius: number): void;
    SetOval(rect: SKRect): void;
    SetRect(rect: SKRect): void;
    SetRect(rect: SKRect, xRadius: number, yRadius: number): void;
    SetRectRadii(rect: SKRect, radii: SKPoint[]): void;
    Transform(matrix: SKMatrix): SKRoundRect;
    TryTransform(matrix: SKMatrix, transformed: Out<SKRoundRect>): boolean;
  }
  export interface SKRoundRect__statics {
    new(): SKRoundRect;
    new(rect: SKRect): SKRoundRect;
    new(rect: SKRect, radius: number): SKRoundRect;
    new(rect: SKRect, xRadius: number, yRadius: number): SKRoundRect;
    new(rrect: SKRoundRect): SKRoundRect;
  }

  export enum SKRoundRectCorner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerRight = 2,
    LowerLeft = 3,
  }

  export enum SKRoundRectType {
    Empty = 0,
    Rect = 1,
    Oval = 2,
    Simple = 3,
    NinePatch = 4,
    Complex = 5,
  }

  export interface SKRunBuffer {
    readonly Size: number;
  }
  export interface SKRuntimeBlenderBuilder {
    readonly Effect: SKRuntimeEffect;
    readonly Uniforms: string[];
    readonly Children: string[];
    Build(): SKBlender;
  }
  export interface SKRuntimeBlenderBuilder__statics {
    new(effect: SKRuntimeEffect): SKRuntimeBlenderBuilder;
  }

  export interface SKRuntimeColorFilterBuilder {
    readonly Effect: SKRuntimeEffect;
    readonly Uniforms: string[];
    readonly Children: string[];
    Build(): SKColorFilter;
  }
  export interface SKRuntimeColorFilterBuilder__statics {
    new(effect: SKRuntimeEffect): SKRuntimeColorFilterBuilder;
  }

  export interface SKRuntimeEffect {
    readonly UniformSize: number;
    readonly Children: string[];
    readonly Uniforms: string[];
    Handle: number;
    ToBlender(): SKBlender;
    ToBlender(uniforms: string[]): SKBlender;
    ToBlender(uniforms: string[], children: string[]): SKBlender;
    ToColorFilter(): SKColorFilter;
    ToColorFilter(uniforms: string[]): SKColorFilter;
    ToColorFilter(uniforms: string[], children: string[]): SKColorFilter;
    ToShader(): SKShader;
    ToShader(uniforms: string[]): SKShader;
    ToShader(uniforms: string[], children: string[]): SKShader;
    ToShader(uniforms: string[], children: string[], localMatrix: SKMatrix): SKShader;
  }
  export interface SKRuntimeEffect__statics {
    CreateShader(sksl: string, errors: Out<string>): SKRuntimeEffect;
    CreateColorFilter(sksl: string, errors: Out<string>): SKRuntimeEffect;
    CreateBlender(sksl: string, errors: Out<string>): SKRuntimeEffect;
    BuildShader(sksl: string): SKRuntimeShaderBuilder;
    BuildColorFilter(sksl: string): SKRuntimeColorFilterBuilder;
    BuildBlender(sksl: string): SKRuntimeBlenderBuilder;
  }

  export interface SKRuntimeEffectBuilder {
    readonly Effect: SKRuntimeEffect;
    readonly Uniforms: string[];
    readonly Children: string[];
  }
  export interface SKRuntimeEffectBuilder__statics {
    new(effect: SKRuntimeEffect): SKRuntimeEffectBuilder;
  }

  export interface SKRuntimeEffectBuilderException {
  }
  export interface SKRuntimeEffectBuilderException__statics {
    new(message: string): SKRuntimeEffectBuilderException;
  }

  export interface SKRuntimeEffectChild {
    readonly Value: SKObject;
    readonly Shader: SKShader;
    readonly ColorFilter: SKColorFilter;
    readonly Blender: SKBlender;
  }
  export interface SKRuntimeEffectChild__statics {
    new(shader: SKShader): SKRuntimeEffectChild;
    new(colorFilter: SKColorFilter): SKRuntimeEffectChild;
    new(blender: SKBlender): SKRuntimeEffectChild;
  }

  export interface SKRuntimeEffectChildren {
    readonly Names: string[];
    readonly Count: number;
    get_Item(name: string): SKRuntimeEffectChild | null;
    Add(name: string, value: SKRuntimeEffectChild | null): void;
    Contains(name: string): boolean;
    Reset(): void;
    ToArray(): SKObject[];
  }
  export interface SKRuntimeEffectChildren__statics {
    new(effect: SKRuntimeEffect): SKRuntimeEffectChildren;
  }

  export interface SKRuntimeEffectUniform {
    readonly IsEmpty: boolean;
    readonly Size: number;
  }
  export interface SKRuntimeEffectUniform__statics {
    Empty: SKRuntimeEffectUniform;
  }

  export interface SKRuntimeEffectUniforms {
    readonly Names: string[];
    readonly Count: number;
    readonly Size: number;
    get_Item(name: string): SKRuntimeEffectUniform;
    Add(name: string, value: SKRuntimeEffectUniform): void;
    Contains(name: string): boolean;
    Reset(): void;
    ToData(): SKData;
  }
  export interface SKRuntimeEffectUniforms__statics {
    new(effect: SKRuntimeEffect): SKRuntimeEffectUniforms;
  }

  export interface SKRuntimeShaderBuilder {
    readonly Effect: SKRuntimeEffect;
    readonly Uniforms: string[];
    readonly Children: string[];
    Build(): SKShader;
    Build(localMatrix: SKMatrix): SKShader;
  }
  export interface SKRuntimeShaderBuilder__statics {
    new(effect: SKRuntimeEffect): SKRuntimeShaderBuilder;
  }

  export interface SKSamplingOptions {
    readonly IsAniso: boolean;
    readonly MaxAniso: number;
    readonly UseCubic: boolean;
    readonly Cubic: SKCubicResampler;
    readonly Filter: SKFilterMode;
    readonly Mipmap: SKMipmapMode;
    Equals(obj: SKSamplingOptions): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKSamplingOptions__statics {
    new(filter: SKFilterMode, mipmap: SKMipmapMode): SKSamplingOptions;
    new(filter: SKFilterMode): SKSamplingOptions;
    new(resampler: SKCubicResampler): SKSamplingOptions;
    new(maxAniso: number): SKSamplingOptions;
    Default: SKSamplingOptions;
  }

  export interface SKShader {
    Handle: number;
    WithColorFilter(filter: SKColorFilter): SKShader;
    WithLocalMatrix(localMatrix: SKMatrix): SKShader;
  }
  export interface SKShader__statics {
    CreateEmpty(): SKShader;
    CreateColor(color: SKColor): SKShader;
    CreateColor(color: SKColorF, colorspace: SKColorSpace): SKShader;
    CreateBitmap(src: SKBitmap): SKShader;
    CreateBitmap(src: SKBitmap, tmx: SKShaderTileMode, tmy: SKShaderTileMode): SKShader;
    CreateBitmap(src: SKBitmap, tmx: SKShaderTileMode, tmy: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateImage(src: SKImage): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode, sampling: SKSamplingOptions): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode, quality: SKFilterQuality): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode, sampling: SKSamplingOptions, localMatrix: SKMatrix): SKShader;
    CreateImage(src: SKImage, tmx: SKShaderTileMode, tmy: SKShaderTileMode, quality: SKFilterQuality, localMatrix: SKMatrix): SKShader;
    CreatePicture(src: SKPicture): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode, tile: SKRect): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode, tile: SKRect): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode, localMatrix: SKMatrix, tile: SKRect): SKShader;
    CreatePicture(src: SKPicture, tmx: SKShaderTileMode, tmy: SKShaderTileMode, filterMode: SKFilterMode, localMatrix: SKMatrix, tile: SKRect): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColor[], mode: SKShaderTileMode): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, mode: SKShaderTileMode): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateLinearGradient(start: SKPoint, end: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColor[], mode: SKShaderTileMode): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColorF[], colorspace: SKColorSpace, mode: SKShaderTileMode): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateRadialGradient(center: SKPoint, radius: number, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[]): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[], colorPos: number[]): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[], colorPos: number[], localMatrix: SKMatrix): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[], tileMode: SKShaderTileMode, startAngle: number, endAngle: number): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[], colorPos: number[], tileMode: SKShaderTileMode, startAngle: number, endAngle: number): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColor[], colorPos: number[], tileMode: SKShaderTileMode, startAngle: number, endAngle: number, localMatrix: SKMatrix): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[]): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], localMatrix: SKMatrix): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, tileMode: SKShaderTileMode, startAngle: number, endAngle: number): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], tileMode: SKShaderTileMode, startAngle: number, endAngle: number): SKShader;
    CreateSweepGradient(center: SKPoint, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], tileMode: SKShaderTileMode, startAngle: number, endAngle: number, localMatrix: SKMatrix): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColor[], mode: SKShaderTileMode): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColor[], colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColorF[], colorspace: SKColorSpace, mode: SKShaderTileMode): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode): SKShader;
    CreateTwoPointConicalGradient(start: SKPoint, startRadius: number, end: SKPoint, endRadius: number, colors: SKColorF[], colorspace: SKColorSpace, colorPos: number[], mode: SKShaderTileMode, localMatrix: SKMatrix): SKShader;
    CreatePerlinNoiseFractalNoise(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number): SKShader;
    CreatePerlinNoiseFractalNoise(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number, tileSize: SKPointI): SKShader;
    CreatePerlinNoiseFractalNoise(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number, tileSize: SKSizeI): SKShader;
    CreatePerlinNoiseTurbulence(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number): SKShader;
    CreatePerlinNoiseTurbulence(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number, tileSize: SKPointI): SKShader;
    CreatePerlinNoiseTurbulence(baseFrequencyX: number, baseFrequencyY: number, numOctaves: number, seed: number, tileSize: SKSizeI): SKShader;
    CreateCompose(shaderA: SKShader, shaderB: SKShader): SKShader;
    CreateCompose(shaderA: SKShader, shaderB: SKShader, mode: SKBlendMode): SKShader;
    CreateBlend(mode: SKBlendMode, shaderA: SKShader, shaderB: SKShader): SKShader;
    CreateBlend(blender: SKBlender, shaderA: SKShader, shaderB: SKShader): SKShader;
    CreateColorFilter(shader: SKShader, filter: SKColorFilter): SKShader;
    CreateLocalMatrix(shader: SKShader, localMatrix: SKMatrix): SKShader;
  }

  export enum SKShaderTileMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2,
    Decal = 3,
  }

  export interface SKSize {
    readonly IsEmpty: boolean;
    Width: number;
    Height: number;
    Equals(obj: SKSize): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToPoint(): SKPoint;
    ToSizeI(): SKSizeI;
    ToString(): string;
  }
  export interface SKSize__statics {
    new(width: number, height: number): SKSize;
    new(pt: SKPoint): SKSize;
    Empty: SKSize;
    Add(sz1: SKSize, sz2: SKSize): SKSize;
    Subtract(sz1: SKSize, sz2: SKSize): SKSize;
  }

  export interface SKSizeI {
    readonly IsEmpty: boolean;
    Width: number;
    Height: number;
    Equals(obj: SKSizeI): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
    ToPointI(): SKPointI;
    ToString(): string;
  }
  export interface SKSizeI__statics {
    new(width: number, height: number): SKSizeI;
    new(pt: SKPointI): SKSizeI;
    Empty: SKSizeI;
    Add(sz1: SKSizeI, sz2: SKSizeI): SKSizeI;
    Subtract(sz1: SKSizeI, sz2: SKSizeI): SKSizeI;
  }

  export interface SKStream {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKStreamAsset {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKStreamMemory {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKStreamRewindable {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export interface SKStreamSeekable {
    readonly IsAtEnd: boolean;
    readonly HasPosition: boolean;
    Position: number;
    readonly HasLength: boolean;
    readonly Length: number;
    Handle: number;
    GetMemoryBase(): number;
    Move(offset: number): boolean;
    Move(offset: number): boolean;
    Peek(buffer: number, size: number): number;
    Read(buffer: number, size: number): number;
    Read(buffer: number[], size: number): number;
    ReadBool(): boolean;
    ReadBool(buffer: Out<boolean>): boolean;
    ReadByte(): number;
    ReadByte(buffer: Out<number>): boolean;
    ReadInt16(): number;
    ReadInt16(buffer: Out<number>): boolean;
    ReadInt32(): number;
    ReadInt32(buffer: Out<number>): boolean;
    ReadSByte(): number;
    ReadSByte(buffer: Out<number>): boolean;
    ReadUInt16(): number;
    ReadUInt16(buffer: Out<number>): boolean;
    ReadUInt32(): number;
    ReadUInt32(buffer: Out<number>): boolean;
    Rewind(): boolean;
    Seek(position: number): boolean;
    Skip(size: number): number;
  }
  export enum SKStrokeCap {
    Butt = 0,
    Round = 1,
    Square = 2,
  }

  export enum SKStrokeJoin {
    Miter = 0,
    Round = 1,
    Bevel = 2,
  }

  export interface SKSurface {
    readonly Canvas: SKCanvas;
    readonly SurfaceProperties: SKSurfaceProperties;
    readonly Context: GRRecordingContext;
    Handle: number;
    Draw(canvas: SKCanvas, x: number, y: number, paint: SKPaint): void;
    Flush(): void;
    Flush(submit: boolean, synchronous?: boolean): void;
    PeekPixels(): SKPixmap;
    PeekPixels(pixmap: SKPixmap): boolean;
    ReadPixels(dstInfo: SKImageInfo, dstPixels: number, dstRowBytes: number, srcX: number, srcY: number): boolean;
    Snapshot(): SKImage;
    Snapshot(bounds: SKRectI): SKImage;
  }
  export interface SKSurface__statics {
    Create(info: SKImageInfo): SKSurface;
    Create(info: SKImageInfo, rowBytes: number): SKSurface;
    Create(info: SKImageInfo, props: SKSurfaceProperties): SKSurface;
    Create(info: SKImageInfo, rowBytes: number, props: SKSurfaceProperties): SKSurface;
    Create(pixmap: SKPixmap): SKSurface;
    Create(pixmap: SKPixmap, props: SKSurfaceProperties): SKSurface;
    Create(info: SKImageInfo, pixels: number): SKSurface;
    Create(info: SKImageInfo, pixels: number, rowBytes: number): SKSurface;
    Create(info: SKImageInfo, pixels: number, rowBytes: number, releaseProc: SKSurfaceReleaseDelegate, context: any): SKSurface;
    Create(info: SKImageInfo, pixels: number, props: SKSurfaceProperties): SKSurface;
    Create(info: SKImageInfo, pixels: number, rowBytes: number, props: SKSurfaceProperties): SKSurface;
    Create(info: SKImageInfo, pixels: number, rowBytes: number, releaseProc: SKSurfaceReleaseDelegate, context: any, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, colorType: SKColorType): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, colorspace: SKColorSpace): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, colorspace: SKColorSpace, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, colorType: SKColorType): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, colorspace: SKColorSpace): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, renderTarget: GRBackendRenderTarget, origin: GRSurfaceOrigin, colorType: SKColorType, colorspace: SKColorSpace, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, colorType: SKColorType): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, colorspace: SKColorSpace): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, colorspace: SKColorSpace, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, colorType: SKColorType): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, colorspace: SKColorSpace): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, texture: GRBackendTexture, origin: GRSurfaceOrigin, sampleCount: number, colorType: SKColorType, colorspace: SKColorSpace, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo, sampleCount: number): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, origin: GRSurfaceOrigin): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, props: SKSurfaceProperties): SKSurface;
    Create(context: GRContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, origin: GRSurfaceOrigin, props: SKSurfaceProperties, shouldCreateWithMips: boolean): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo, sampleCount: number): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, origin: GRSurfaceOrigin): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, props: SKSurfaceProperties): SKSurface;
    Create(context: GRRecordingContext, budgeted: boolean, info: SKImageInfo, sampleCount: number, origin: GRSurfaceOrigin, props: SKSurfaceProperties, shouldCreateWithMips: boolean): SKSurface;
    CreateNull(width: number, height: number): SKSurface;
  }

  export interface SKSurfaceProperties {
    readonly Flags: SKSurfacePropsFlags;
    readonly PixelGeometry: SKPixelGeometry;
    readonly IsUseDeviceIndependentFonts: boolean;
    Handle: number;
  }
  export interface SKSurfaceProperties__statics {
    new(pixelGeometry: SKPixelGeometry): SKSurfaceProperties;
    new(flags: number, pixelGeometry: SKPixelGeometry): SKSurfaceProperties;
    new(flags: SKSurfacePropsFlags, pixelGeometry: SKPixelGeometry): SKSurfaceProperties;
  }

  export enum SKSurfacePropsFlags {
    None = 0,
    UseDeviceIndependentFonts = 1,
  }

  export type SKSurfaceReleaseDelegate = (address: number, context: any) => void;

  export interface SKSvgCanvas {
  }
  export interface SKSvgCanvas__statics {
    Create(bounds: SKRect, stream: SKWStream): SKCanvas;
  }

  export interface SKSwizzle {
  }
  export interface SKSwizzle__statics {
    SwapRedBlue(pixels: number, count: number): void;
    SwapRedBlue(dest: number, src: number, count: number): void;
  }

  export enum SKTextAlign {
    Left = 0,
    Center = 1,
    Right = 2,
  }

  export interface SKTextBlob {
    readonly Bounds: SKRect;
    readonly UniqueId: number;
    Handle: number;
    CountIntercepts(upperBounds: number, lowerBounds: number, paint?: SKPaint): number;
    GetIntercepts(upperBounds: number, lowerBounds: number, paint?: SKPaint): number[];
  }
  export interface SKTextBlob__statics {
    Create(text: string, font: SKFont, origin?: SKPoint): SKTextBlob;
    Create(text: number, length: number, encoding: SKTextEncoding, font: SKFont, origin?: SKPoint): SKTextBlob;
    CreatePathPositioned(text: string, font: SKFont, path: SKPath, textAlign?: SKTextAlign, origin?: SKPoint): SKTextBlob;
    CreatePathPositioned(text: number, length: number, encoding: SKTextEncoding, font: SKFont, path: SKPath, textAlign?: SKTextAlign, origin?: SKPoint): SKTextBlob;
  }

  export interface SKTextBlobBuilder {
    Handle: number;
    AllocateHorizontalRun(font: SKFont, count: number, y: number, bounds?: SKRect | null): SKHorizontalRunBuffer;
    AllocateHorizontalTextRun(font: SKFont, count: number, y: number, textByteCount: number, bounds?: SKRect | null): SKHorizontalTextRunBuffer;
    AllocatePositionedRun(font: SKFont, count: number, bounds?: SKRect | null): SKPositionedRunBuffer;
    AllocatePositionedTextRun(font: SKFont, count: number, textByteCount: number, bounds?: SKRect | null): SKPositionedTextRunBuffer;
    AllocateRawHorizontalRun(font: SKFont, count: number, y: number, bounds?: SKRect | null): SKRawRunBuffer<number>;
    AllocateRawHorizontalTextRun(font: SKFont, count: number, y: number, textByteCount: number, bounds?: SKRect | null): SKRawRunBuffer<number>;
    AllocateRawPositionedRun(font: SKFont, count: number, bounds?: SKRect | null): SKRawRunBuffer<SKPoint>;
    AllocateRawPositionedTextRun(font: SKFont, count: number, textByteCount: number, bounds?: SKRect | null): SKRawRunBuffer<SKPoint>;
    AllocateRawRotationScaleRun(font: SKFont, count: number, bounds?: SKRect | null): SKRawRunBuffer<SKRotationScaleMatrix>;
    AllocateRawRotationScaleTextRun(font: SKFont, count: number, textByteCount: number, bounds?: SKRect | null): SKRawRunBuffer<SKRotationScaleMatrix>;
    AllocateRawRun(font: SKFont, count: number, x: number, y: number, bounds?: SKRect | null): SKRawRunBuffer<number>;
    AllocateRawTextRun(font: SKFont, count: number, x: number, y: number, textByteCount: number, bounds?: SKRect | null): SKRawRunBuffer<number>;
    AllocateRotationScaleRun(font: SKFont, count: number, bounds?: SKRect | null): SKRotationScaleRunBuffer;
    AllocateRotationScaleTextRun(font: SKFont, count: number, textByteCount: number, bounds?: SKRect | null): SKRotationScaleTextRunBuffer;
    AllocateRun(font: SKFont, count: number, x: number, y: number, bounds?: SKRect | null): SKRunBuffer;
    AllocateTextRun(font: SKFont, count: number, x: number, y: number, textByteCount: number, bounds?: SKRect | null): SKTextRunBuffer;
    Build(): SKTextBlob;
  }
  export interface SKTextBlobBuilder__statics {
    new(): SKTextBlobBuilder;
  }

  export enum SKTextEncoding {
    Utf8 = 0,
    Utf16 = 1,
    Utf32 = 2,
    GlyphId = 3,
  }

  export interface SKTextRunBuffer {
    readonly TextSize: number;
    readonly Size: number;
  }
  export interface SKTraceMemoryDump {
    Handle: number;
  }
  export enum SKTrimPathEffectMode {
    Normal = 0,
    Inverted = 1,
  }

  export interface SKTypeface {
    readonly FamilyName: string;
    readonly FontStyle: SKFontStyle;
    readonly FontWeight: number;
    readonly FontWidth: number;
    readonly FontSlant: SKFontStyleSlant;
    readonly IsBold: boolean;
    readonly IsItalic: boolean;
    readonly IsFixedPitch: boolean;
    readonly UnitsPerEm: number;
    readonly GlyphCount: number;
    readonly TableCount: number;
    readonly HasGetKerningPairAdjustments: boolean;
    Handle: number;
    ContainsGlyph(codepoint: number): boolean;
    ContainsGlyphs(text: string): boolean;
    ContainsGlyphs(text: number, length: number, encoding: SKTextEncoding): boolean;
    CountGlyphs(str: string): number;
    CountGlyphs(str: number[], encoding: SKTextEncoding): number;
    CountGlyphs(str: number, strLen: number, encoding: SKTextEncoding): number;
    GetGlyph(codepoint: number): number;
    GetGlyphs(text: string): number[];
    GetGlyphs(text: number, length: number, encoding: SKTextEncoding): number[];
    GetTableData(tag: number): number[];
    GetTableSize(tag: number): number;
    GetTableTags(): number[];
    OpenStream(): SKStreamAsset;
    OpenStream(ttcIndex: Out<number>): SKStreamAsset;
    ToFont(): SKFont;
    ToFont(size: number, scaleX?: number, skewX?: number): SKFont;
    TryGetTableData(tag: number, tableData: Out<number[]>): boolean;
    TryGetTableData(tag: number, offset: number, length: number, tableData: number): boolean;
    TryGetTableTags(tags: Out<number[]>): boolean;
  }
  export interface SKTypeface__statics {
    Default: SKTypeface;
    CreateDefault(): SKTypeface;
    FromFamilyName(familyName: string, weight: number, width: number, slant: SKFontStyleSlant): SKTypeface;
    FromFamilyName(familyName: string): SKTypeface;
    FromFamilyName(familyName: string, style: SKFontStyle): SKTypeface;
    FromFamilyName(familyName: string, weight: SKFontStyleWeight, width: SKFontStyleWidth, slant: SKFontStyleSlant): SKTypeface;
    FromFile(path: string, index?: number): SKTypeface;
    FromStream(stream: SKStreamAsset, index?: number): SKTypeface;
    FromData(data: SKData, index?: number): SKTypeface;
  }

  export enum SKVertexMode {
    Triangles = 0,
    TriangleStrip = 1,
    TriangleFan = 2,
  }

  export interface SKVertices {
    Handle: number;
  }
  export interface SKVertices__statics {
    CreateCopy(vmode: SKVertexMode, positions: SKPoint[], colors: SKColor[]): SKVertices;
    CreateCopy(vmode: SKVertexMode, positions: SKPoint[], texs: SKPoint[], colors: SKColor[]): SKVertices;
    CreateCopy(vmode: SKVertexMode, positions: SKPoint[], texs: SKPoint[], colors: SKColor[], indices: number[]): SKVertices;
  }

  export interface SKWStream {
    readonly BytesWritten: number;
    Handle: number;
    Flush(): void;
    NewLine(): boolean;
    Write(buffer: number[], size: number): boolean;
    Write16(value: number): boolean;
    Write32(value: number): boolean;
    Write8(value: number): boolean;
    WriteBigDecimalAsText(value: number, digits: number): boolean;
    WriteBool(value: boolean): boolean;
    WriteDecimalAsTest(value: number): boolean;
    WriteHexAsText(value: number, digits: number): boolean;
    WritePackedUInt32(value: number): boolean;
    WriteScalar(value: number): boolean;
    WriteScalarAsText(value: number): boolean;
    WriteStream(input: SKStream, length: number): boolean;
    WriteText(value: string): boolean;
  }
  export interface SKWStream__statics {
    GetSizeOfPackedUInt32(value: number): number;
  }

  export enum SKWebpEncoderCompression {
    Lossy = 0,
    Lossless = 1,
  }

  export interface SKWebpEncoderOptions {
    readonly Compression: SKWebpEncoderCompression;
    readonly Quality: number;
    Equals(obj: SKWebpEncoderOptions): boolean;
    Equals(obj: any): boolean;
    GetHashCode(): number;
  }
  export interface SKWebpEncoderOptions__statics {
    new(compression: SKWebpEncoderCompression, quality: number): SKWebpEncoderOptions;
    Default: SKWebpEncoderOptions;
  }

  export enum SKZeroInitialized {
    Yes = 0,
    No = 1,
  }

  export interface SkiaExtensions {
  }
  export interface SkiaExtensions__statics {
    IsBgr(pg: SKPixelGeometry): boolean;
    IsRgb(pg: SKPixelGeometry): boolean;
    IsVertical(pg: SKPixelGeometry): boolean;
    IsHorizontal(pg: SKPixelGeometry): boolean;
    GetBytesPerPixel(colorType: SKColorType): number;
    GetBitShiftPerPixel(colorType: SKColorType): number;
    GetAlphaType(colorType: SKColorType, alphaType?: SKAlphaType): SKAlphaType;
    ToGlSizedFormat(colorType: SKColorType): number;
    ToSamplingOptions(quality: SKFilterQuality): SKSamplingOptions;
  }

  export interface StringUtilities {
  }
  export interface StringUtilities__statics {
    GetUnicodeCharacterCode(character: string, encoding: SKTextEncoding): number;
    GetEncodedText(text: string, encoding: SKTextEncoding): number[];
    GetString(data: number, dataLength: number, encoding: SKTextEncoding): string;
    GetString(data: number[], encoding: SKTextEncoding): string;
    GetString(data: number[], index: number, count: number, encoding: SKTextEncoding): string;
  }

}

